* 实现
   - ECMAScript是javascript标准。一般情况下这两个词我们认为是一个意思
   - JavaScript： ECMAScript DOM(文档对象模型) BOM（浏览器对象模型）
* 特定
   - 解释型语言
   - 类似于C和java的语法结构
   - 基于原型的面向对象
   - 动态语言
* 简单语法
   alert("弹出一个警告");
   document.write("向文档中写入内容");
   console.log("输出到控制台");
   prompt()可以弹出一个提示框，这提示框中会代有一个文本框
           用户可以在文本框输入一段内容，该函数需要一个字符串作为参数
           该字符串作为提示框的提示文字,用户输入的内容会作为函数的返回值
           返回
   可以利用变量来接收该内容

* 编写位置
   1. 可以将js写在超链接的href属性中，这样当点击超连接时，会执行js
   2. 可以将js代码编写到外部js文件中，然后通过script标签引入
      写入到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓冲机制
   3. script标签一旦用于引入外部文件，就不能编写代码了，即使编写了也会忽略
* 基本语法
*** 注释
    /* */ 多行注释，注释中的内容不会被执行。但是可以在源代码中查看
    // 单行注释
    js中严格区分大小写
*** 注意
    1. JS中严格区分大小写
    2. JS中每一条语句以分号
       - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源
       - 浏览器会加错
* 字面量和变量及标识符
*** 字面量
    都是一些不可改变的值
    1 2 3 4 5 6
    字面量都是可以直接使用，但是我们一般都不会直接使用字面量
*** 变量
    变量可以用来保存字面量，而且变量的值是可以任意改变的
    变量更加方便我们使用，所以在开发中都是通过变量通过变量去保存一个字面量
    声明变量
    在Js中使用var关键字来声明一个变量
    var a;
    a=123; 使用变量来保存字面量
** 标识符
    - 在JS中所有可以由我们自主命名的都可以称为标识符
    - 例如： 变量名，函数名，属性名都属于标识符
    - 命名一个标识符时需要遵守如下的规则：
      1. 标识符中可以含有字母，数字，_,$
      2. 标识符不能以数字开头
      3. 标识符不能是ES中关键字中的关键字或保留字
      4. 标识符一般都采用驼峰命名法
         - 首字母小写，每个单词开头字母大写，其余小写
    - JS底层保存标识符时实际上采用的Unicode编码
      所以理论上讲，所有utf-8中含有的内容都可以作为标识
* 数据类型
*** 基本介绍
    一共六种数据类型
    String 字符串
    Number 数值
    Boolean 布尔值
    Null 空值
    Undefined 未定义
    Object 对象
    String Number Boolean Null Undefined 属于基本数据类型
    Object 属于引用数据类型
*** String字符串
    - js中字符串需要""(引号)
    - 使用双引号或单引号都行,但是不要混用
    - 引号不能嵌套,双引号里面不能放双引号...
    - 在字符串中我们可以使用\(斜杠)作为转义字符
      \"(斜杠双引号)表示"(双引号)
      \'(斜杠单引号)表示‘(单引号)
      \n 表示换行
      \t 制表符
      \\ 表示\
    - 字符串相乘：返回NaN not a number
*** 检查变量类型
    来检查变量的类型
    语法： typeof 变量
*** Number
    JS中所有数值都是Number
    包括整数和浮点数（小数）
    JS中可以标识的数字的最大值
    Number.MAX_VALUE
    1.7976931348623157e+308
    如果使用Number表示的数字超过了最大值，则会表示infinity,表示正无穷
    -infinity表示负无穷
    使用typeof检查infinity也会返回Number
    字符串相乘：返回nan也是Number类型
    最小的正值 5e-324
    如果JS进程浮点运算，可能导致一个不精确的结果
*** Boolean 布尔值
    ture
       - 逻辑真
    false
       - 逻辑判断
*** Null
    只有一个null
    专门用来表示空对象
    使用typeof检查null值时会返回object
*** undefined
    只有一个值undefined
    当声明一个变量，但是并不给变量赋值，它的值就是undefined
*** 强制类型转换
    - 指将一个数据类型转换为其它的数据类型
    - 主要指，将其它的数据类型，转换为
      String,Number,Boolean
    - 调用被转换数据类型的toString方法
      var a=123  var b=a.toString(); a=a.toString();
    - 但是注意： null和underfined 这两个值没有toString方法
    - 调用String()函数，并将被转换的数据作为参数传递给函数
    - 使用String()函数做强制类型转换时
      对于Number和Boolean实际上就是调用的toString()方法
      但是对于null和underfined，就不会调用toString()
          它会将null直接转换为"null"
          将underfined直接转换"underfined"
*** 将其它数据类型转换为Number
    转换方式一：
         使用Number()类型
         - 字符串--> 数字
           1. 如果是纯数字的字符串，则直接将其转换为数字
           2. 如果字符串中有非数字的内容，则将其转换为NaN
           3. 如果字符串是一个空串或者是一个全是空格的字符串
              则转换为0
         - 布尔 --> 数字
           true 转成 1
           false 转成 0
         - Null -->数字 == 0
    转换方式二:
        - 专门用来对付字符串
        - parseInt()可以将一个字符串中的有效的整数内容取出来
          然后转换为Number
        - 如果对非String使用paraseInt()或parseFloat()
          它会先将其转换为String,然后再操作
          a=“070”
    a=parseInt(a,10) 将a作为10进制转换
    第二个参数来指定进制
*** 其它进制的数字
    在js中，如果需要表示16进制的数字，则需要0x开头
    如果需要表示8进制的数字，则需要以0开头
    如果需要表示2进制的数字，则需要以0b开头
    但是不有浏览器都支持
*** 转换为Boolean值
    - 使用Boolean()函数来将a转换为布尔值
      - 数字---> 布尔
        - 除了0和NaN,其余的都是true
        - 字符串 ---> 布尔
          除了空串，其余都是true
        - null和underfined都会转换为false
        - 其它对象也会转换为true

* 运算符
** 基本介绍
   通过运算符可以对一个或多个值进行运算，并获取运算结果
   比如： typeof就是运算符，可以来获取一个值的类型
          将该类型以字符串的形式返回
          number string boolean underfined object
   当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算
   任何数字和NAN做运算都是NAN
   两个字符串相加的结果为拼接,并且返回
   任何的值和字符串做加法运算，都会先转换字符串，然后再和字符串做拼串的操作
   我们可以利用这一特点，来将任意一个数据类型转换为String
    我们只需要为任意数据类型+一个""
   - 可以对两个值进行减法运算
     此时数值都会转换成NUMBER
** 算术运算符
   +  可以对两个值进行加法运算，并将结果返回
   -
   *
   /
   %

** 一元运算符
*** 自增
    - 通过自增可以使变量在自身的基础上增加1
    - 对于一个变量自增以后。原变量的值会立即自增1
    - 自增分成两种。后++(a++)和前++(++a)
      无论是a++.还是++a.都会立即使原变量的值自增
*** 自减
    - 通过自减可以使变量在自身的基础上减1
    - 自减分成两种，后--(a--)和前--(--a)
*** 逻辑运算符
    - ！ 非 ！可以用来对一个值进行非运算
    - 所谓非运算就是值对一个布尔值进行取反操作
      true变false
    - 如果对一个值进行两次取反，它不会变化
    - 如果对布尔值进行取法，则会将其转换为布尔值
      我们可以利用该特点，来将一个其它数据类型转换为布尔值
      可以为任意数据类型取两次反，来将其转换为布尔值
    && 与
    - && 可以对符号两侧的值进行与运算并返回结果
    - 运算规则
      - 如果两个值都是true则返回true
    - JS中的"与"属于短路与“

    - || 或 只要有true都为true
*** 对于非布尔值的情况
    会先将其转换成布尔值，然后再运算
    非零数字转换布尔值为true
    ""||" hello" input hello
       && || 非布尔值的情况
       如果第一个值为false直接返回第二个值

** 赋值运算符
   =
     可以将符号右侧的值赋值给左侧的变量
   +=
     a+=5 等价于a=a+5
   *=
   /=
   %=

** 关系运算符
   通过关系运算符可以比较两个值之间的大小关系
       如果关系成立它会返回true,如果不成立则会返回false
   > 大于号
     - 判断左侧的值是否大于右侧的值
     - 如果关系成立，返回true,如果关系不成立，则返回false
   非数值的情况
   - 对于非数值进行比较时，会将其转换成数值，然后进行比较
   - 如果符合两侧的值都是字符串不会将其转换成数字进行比较
     则会分别比较字符串中字符的Unicode编码
   - 比较字符编码时是一位一位进行比较
   - 如果两位一样，则比较下一位，所以借用它来对英文进行排序
   - 如果比较两个字符串类型的数字，可能会得到不可预期的结果

** 相等运算符
   相等运算符用来比较两个值是否相等，如果相等返回true，否则返回false
   使用==来做相等运算
   - 当使用==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为
     相同的类型
   - “1”==1 true=="1" 都是true
   - underfined 衍生自null
   - NaN不和任何值相等，包括他本身
   - 如何判断b的值是否是NaN
     isNaN()函数来判断一个值是否是NaN
   不相等
        不相等用来判断两个值是否不相登
    - 使用!=来做不相等运算
    - 不相登也会对变量进行自动类型转换，如果转换后相等，也会返回false
   全等 ==(三个 等号)=
     - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动类型转换
       如果两个值的类型不同，直接返回false
   不全等
     - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换
       如果两个值的类型不同，直接返回true
** 条件运算符（三元运算符）
   语法：
        条件表达式?语句1:语句2
   - 执行的流程:
         条件运算符在执行时，首先对条件表达式进行求值
         如果该值为true,则执行语句1，并返回执行结果
         如果该值为false.则执行语句2，并返回执行结果
   - 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值，然后在运算
** 运算符的优先级
   使用，可以分割多个语句，一般可以在声明多个变量时使用逗号
   运算符同时声明多个变量, 同时赋值
   就和数学中一样，在JS中运算符也有优先级
   比如，先乘除，后加减
   如果||的优先级高，或者两个一样高,则应该返回3
   如果与的优先级高，则应该返回1
   在表中越靠上优先级越高，优先级越高越优先
   如果优先级一样，则从左往右计算
** 优先级表
   - . [] new
   - ()
   - ++ --
   - ! ~ +(单目) -(单目) typeof void delete
   - % * /
   - +(双目) -(双目)
   - << >> >>>
   - < <= > =>
   - ==(两个等于) !== ===
   - &
   - ^
   - |
   - &&
   - ||
   - ?:
   - = += -= *= /= %= <<= >>= >>>= &= ^= |=
* Unicode编码
** 编码输出
    "\ucode"
   在网页中使用
   &#编码,这里的编码需要的是10进制

* 语句
** 简介
   - 语句是我们这个语言中一句一句完整的话
   - 语句是一个程序的基本单位，JS程序就是由一条一条语句构成的，每一条语句使用
     ; 结尾
   - JS中的语句默认是由上至下顺序来执行的，但是我们可以通过一些流程控制语句来
     控制语句的执行顺序
   - JS中可以使用{}来为语句进行分组
         同一个{}中的语句我们称为一组语句
         它们要么都执行，要么都不执行
         一个{}中的语句，称为一个代码块
   - JS中的代码块，只具有分组的作用，没有其它的用途
     代码块中的内容，在外部是完全可见的

** 控制语句
   - 通过流程控制语句可以控制程序执行
     使程序可以根据一定的条件来选择执行
   - 语句的分类
     1. 条件判断语句
     2. 条件分支语句
     3. 循环语句
   - 条件判断语句：
     - 使用条件判断语句可以在执行某个语句之前进行判断
     - 如果条件成立才会执行语句，条件不成立则语句不执行
** if语句
   - if语句
     语句一:
     if(条件表达式) 语句
          语句
     if语句在执行时，会先对条件表达式进行求值判断
     如果条件表达式的值为true,则执行if语句后的语句
     如果条件表达式的值为false，则不会执行if后的语句
     可以将这些语句统一放到代码块中
     if语句后的代码块不是一样的，但是在开发中尽量写上代码块,即使if后只有一条语句
   - if语法
     if(条件表达式){
         语句...
     }else{
         语句...
     }
     if...else...语句
     if...else if...
     当语句执行时，会先对if后的条件表达式进行求值判断,
     如果该值为true,则执行if后的语句
     否则，则执行else后的语句

** switch
   语句:
      switch(条件表达式){
         case 表达式:
              语句...
              break;
         case 表达式:
              语句...
              break;
   switch...case...语句
   在执行时会一次将case后的表达式的值和switch后的条件表达式进行全等比较
   如果比较结果为true，则从当前case开始执行代码
   - 当前case后的所有代码都会执行，可以在case后跟着一个break关键字
     这样可以确保只会执行当前case后的语句，而不会执行其他的case
   如果比较结果为false,则继续向下比较
   如果所有结果都为false,则只执行default后的语句
   switch语句和if语句的功能实际上重复的，使用swicth可以实现if的功能

** 循环语句
*** while循环
    while(条件表达式){
       语句...
    }
    先对条件表达式进行判断，
    如果值为true，则执行循环体
    循环体执行完毕，继续对表达式进行判断，以此类推
    如果为false，则终止循环
    //创建一个循环，需要三个步骤
    1. 创建一个初始化一个变量
    2. 在循环中设置一个条件表达式
    3. 定义一个更新表达式，每次定义初始化变量
       do{
         语句...
       }while(条件表达式)
*** for循环
    1. 初始化表达式
    2. 条件表达式
    3. 更新表达式
       for(1;2;3){
         语句...
       }
    执行顺序
    1 2 语句 3
    for(;;) 死循环
    break outer; 终止外层循环
    continue 关键字可以用来跳过当次循环
** 计算时间
   console.time("计时器名称");
   console.time("要停止的计时器名称")

* 对象(包括数组)
** 简介
    String 字符串 Number 数值 Boolean 布尔值 Null 空值 Underfined 未定义
     - 以上这五种类型属于基本数据类型，以后我们看到的值不是
       上边5种，全都是对象
     值和值之间没有任何的联系
   - Object 对象
     对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性

** 分类
   1. 内建对象
      由ES标准中定义的对象，在任何的ES的实现中都可以使用
      Math String
   2. 宿主对象
      由JS运行环境提供的对象，目前来讲由浏览器提供的对象
      BOM DOM
   3. 自定义对象
      var obj=new Object();
      使用new关键字调用的函数，是构造函数const
      构造函数是专门用来创建对象的函数
** 创建和读取对象
   1. 使用typeof检查一个对象时，会返回object
      在对象中保存的值称为属性
      向对象添加属性
      对象.属性名=属性值
   2. 读取对象中的属性
      obj.name
   3. 删除对象的属性
      delete 对象.属性名 delete.name
** 规范
   属性名
   - 对象的属性名不强制要求遵守标识符的规范
   - 但是尽量按照标志符的规范做
   - 使用特殊的属性名，不能采用.的方式来做
     需要使用另一种方式
     对象["属性名"]=属性值
   - 使用[]这种形式操作属性，更加灵活
     在[]中可以直接传递一个变量
   属性值
     JS对象的属性值，可以是任意的数据类型
     甚至也可以是一个对象
   in 运算符
   - 通过该运算符可以检查一个对象中是否含有指定的属性
   - 语法
       "属性名" in 对象
   使用对象字面量，可以在创建对象时，直接指定对象中的属性
     语法: {属性名:属性值,属性名:属性值}
     对象字面量的属性名可以加也可以不加
     名和值之间使用:连接，多个名值对之间使用，循环
** JS内存
   JS的变量都是保存到栈内存中
   基本数据类型的值直接在栈内存存储
   值与值是独立存在，修改一个变量不会影响其它变量

   引用数据类型
   - 对象的值是保存到堆内存中
   - 对象名实质上在栈中保存的是地址

** 数组(内建对象)
*** 简介
   - 数组也是一个对象
   - 它和普通的对象功能类似，也是用来存储一些值的
   - 不同的是普通对象是使用字符串作为属性名的，
     而我们的数组是使用数字来作为索引操作元素
   - 索引
     从0开始的整数就是索引
   - 数组的存储性能要比普通对象要好,在开发中我们经常使用数组来存储一些数据
   - ar arr=new Array();
   - 通过索引来添加元素
     读取数组中的元素 语法 arr[0]
     如果读取不存在的索引它不会报错，他不会报错而是返回underfined
     arr.length 来获取数组的长度
   - 对于连续的数组，使用length可以获取到数组的长度(元素的个数)
     对于非连续的数组，使用length可以获取数组的最大的索引+1
   - 可以修改length，如果修改的length大于原长度，则多出的部分会空出来
     arr[arr.length]=值
*** 创建数组
    var arr2=new Array(10,20,30);
    - 使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的
      参数床第
    - 注意null,underfined没有任何值,在数组中表示为",,"
*** 数组的方法
**** 数组的添加或删除
     push()
     - 该方法可以向数组末尾中添加一个或多个元素，并返回数组新的长度
     - 可以将要添加的元素作为方法的参数传递
       这些元素将会自动添加到数组的末尾
     pop()
     - 删除并返回数组的最后一个元素
     unshift()
     - 向数组的开头添加一个或更多元素，并返回新的长度
     - 向前边插入元素以后，其他元素索引会依次调整
     shift()
     - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回
     slice(start,end)
     - 从某个已有的方法返回选定的元素
     - 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回
     - start 规定从何处开始截取 end规定从何处结束截取
       end可以省略不写
     - 可以传递一个负值,则表示从后往前计算. -1表示倒数第一个，-2表示倒数第二个
     splice()
     - 删除元素，并向数组添加新元素
     - 使用splice()会影响到原数组，会将指定元素从原数组中删除,并将删除的元素作为
       返回值返回
     参数:
       - 第一个，表示开始位置索引
       - 第二个，表示删除的数量
       - 第三个及以后，可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
**** 其它方法
     concat(arr1,arr2,...,"String")
     - 可以连接两个或多个数组(或者元素)，并将新的数组返回
     - 该方法不会对原数组产生影响
     join()
     - 该方法可以将数组转换为一个字符串
     - 该方法不会对数组产生影响，而是将转换后的字符串作为结果
     - 在join中，可以指定一个字符串作为参数，这个字符串将成为数组
       元素的连接符取代(,)逗号
     reverse()
     - 该方法用来反转数组（前边的去后边，后边的去前边）
     - 该方法直接修改原数组
     sort()
     - 可以用来对数组的元素进行排序
     - 也会影响原数组,默认会按照Unicode编码（注意各个国家的Unicode的
       编码有可能不同）进行排序
     - 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来进行排序
     - 所以对数字进行排序时，可能会得到错误的结果
     - 我们可以自己制定排序的规则
       我们可以在sort()中添加一个回调函数，来指定排序规则,
       回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用
       回调函数
     - 使用哪个元素调用不确定，在数组中a一定在b前面
       arr.sortfunction(a,b){
        if(a>b)return 1;
        else if(a<b>)return -1;
        else return 0;
       }
     - 浏览器会根据回调函数的返回值来决定元素的顺序，如果返回一个大于0的值，
       则元素会交换位置，如果返回一个小于0的值，则元素位置不变
       如果返回一个等于0，则认为两个元素相等，也不交换位置
       如果需要升序排列，则返回a-b
       如果需要降序排列，则返回b-a
*** 遍历数组
    一般我们都是使用for循环去遍历数组，JS中还为我们提供一个机会,用来遍历数组
    forEach()
     - 这个方法只支持IE8以上的浏览器
     - arr.forEach(function(value,index,c)){}
     - 像这种函数，我们创建但是不由我们调用的，我们称为回调函数
     - 数组中有几个元素函数就会执行几次,每次执行时，浏览器会将遍历到的元素以
       实参的形式传递进来,我们可以来定义形参，来读取这些内容
     - 浏览器会在回调函数中传递三个参数，
       第一个参数，就是当前正在遍历的元素
       第二个参数，就是当前正在遍历的元素的索引
       第三个参数，就是正在遍历的数组
** Date对象
*** 简介
   - 在JS中使用Date对象来表示一个时间，则会封装为当前代码的执行时间
     var d=new Date()
   - 创建一个指定的时间对象
     需要在构造函数中传递一个表示时间的字符串作为参数
     日期格式 年/月/日 时:分:秒
     var d2=new Date("12/03/2016 11:10:00")
*** 方法
    getDate()
    - 获取当前日期对象是几日
    getDay()
    - 从Date对象返回一周中的某一天(0-6 0表示周日)
    getMonth()
    - 从Date对像中返回月份 11表示12月
    getFullYear()
    - 获取当前日期对象的年份 使用当前数字
    getTime()
    - 获取当前日期对象的时间戳
    - 从格林威治标准时间的1970年1月1日，0时0分秒
      到当前日期的毫秒数(1秒=1000毫秒)
    - 计算机底层在保存时间时，使用的都是时间戳
      time/1000/60/60/24/365
    - 注意时区

** Math
   不是构造函数，和其他对象不同
   它属于一个工具类，不用创建对象，它里边封装了数学运算相关的属性和方法
   Math.PI
   Math.SQRT
   Math.ceil()
   - 可以对一个数进行向上取整, 小数位只要有值就自动进1
   Math.floor()
   - 可以对一个数进行向下取整
   Math.round()
   - 可以对一个数进行四舍五入取整
   Math.random()
   - 可以用来生成一个0-1之间的随机数
   max()
   - 可以获取多个数中的最大值
   min()
   Math.pow(x,y) x的y次冥
* 函数
** 简介
   - 函数也是一个对象
   - 函数中可以封装一些功能(代码)，在需要时可以执行这些功能(功能）
   - 函数中可以保存一些代码在需要的时候调用
   - 使用typeof检查一个函数对象时，会返回function
   - 可以将要封装的代码以字符串的形式传递给构造函数
   - 封装到函数中的代码不会立即执行
   - 调用函数语法，函数对象()
   - 当调用函数时，函数中封装的代码会按照编写的顺序执行
** 函数使用
   使用函数声明来创建一个函数
   语法中的中括号表示可选
   语法:
      function 函数名([形参1,形参2...形参N]）{
         语句
      }
      function fun2(a,b){
         console.log(a+b);
      }
      sum(var1,var2)
     1. 声明形参表示在函数内部声明了对应的变量，但是并不赋值，在调用函数时,
  可以在()中指定实参(实际参数)
     2. 实参可以赋值给函数中对应的形参
     3. 调用函数解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的
  参数，如果有可能则需要对参数进行类型的检查
     4. 如果实参的数量少于形参的数量，则没有对应实参的形参将是underfined
      函数的实参可以是任意数据类型
** 函数的返回
   可以使用return 来设置函数的返回值
   语法: return 值
   - return 后的值将会作为函数的结果返回
   - 可以定义变量来接收该结果
   - 在函数中return后的语句都不会执行
   - return语句后不跟任何值，则也会返回underfined
   - 如果函数中不写返回，也是underfined
     mainji()
     - 调用函数
     - 相当于使用函数的返回值（传递对象的返回值）
     minaji
     - 函数对象
     - 相当于直接使用函数对象（传递对象本身）
   - 返回值的类型
     return 可以结束整个函数
     continue 可以结束当次循环
     可以是任意数据类型 可以是对象或者函数
     return fun4() 返回函数的返回值
     return fun4  将fun4函数对象作为返回值返回

** 匿名函数
   函数定义完，立即被调用
   (function(a.b){
   alert("我是一个匿名函数~~~");
   })(1,2)
   函数也可以称为对象的属性
    如果一个函数作为一个对象的属性保存
    那么我们称这个函数时这个对象的方法
    调用函数就说调用对象的方法
   var obj.sayName=function fun(){console.log()}
   obj.sayName
   fun();
   只是名称的区别
   var obj2={
     name="猪八戒",
     age:18,
     sayname:function(){
     console.log(obj2.name
     );
   }
   }
** 枚举对象中的属性
   使用for ... in语句
   for(var a in obj){
    console.log(n);
    //obj[n]
   }
   每次执行都会将对象中的属性赋值给变量
** 作用域
   - 作用域是指一个变量作用的范围
   - 两种作用域
     全局作用域
     - 直接编写在script标签中的JS代码，都在全局作用域中
     - 全局作用域在页面打开时创建，在页面关闭时销毁
     - 在全局作用域中有一个全局对象window,可以直接使用
        它代表的是一个浏览器窗口，在浏览器创建时我们可以直接使用
     - 在全局作用域中
        创建的变量都会作为windows对象的属性保存
     - 创建的函数都会作为windows对象的方法保存
       window.fun()
     - 使用var关键字声明的变量,会在所有代码执行之前被声明
     - 但是如果声明变量不是使用var关键字,则变量不会被声明提前
     函数作用域
     - 使用函数声明形式创建的函数function 函数(){}
       它会在所有的代码执行
     全局作用域中的变量都是全局变量

** 函数作用域
   - 调用函数时，创建函数作用域，函数执行完毕以后，函数作用域销毁
   - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
   - 在函数作用域中可以访问到全局作用域的变量,
     在全局作用域中无法访问到函数作用域的变量
   - 当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就
     直接使用，如果没有，则向上一级作用域中寻找,直到找到全局作用域
     如果全局作用域中依然没有找到，则会报错，引用异常
   - 如果在函数中调用全局变量，建议添加windwos.varname，不加windows就是就近
   - 在函数作用域中也有声明提前的特性，使用var关键字声明的变量，会在函数中
     所有的代码执行之前被声明
   - 函数声明也会在函数中所有的代码执行之前执行
   - 定义形参就相当于在函数作用域中声明了变量
** this
   解析器在调用函数时每次都会向函数内部传递进隐含的参数,
   这个隐含参数就是this,this指代window,this指向的是一个对象
   这个对象我们函数执行的上下文对象
   根据this函数的调用方式不同，this会指向不同的对象
   1. 以函数形式调用时，this永远都是window
   2. 以方法的形式调用时，this就是调用方法的对象
      var name="全局"
      var obj=obj{
       console.log(this.name);
      }

** 构造函数
   使用工厂方式创建的对象，使用的构造函数都是object类型，导致无法区分不同
   类型的对象
   构造函数就是一个普通函数，创建方式都是一样，不同的是构造函数习惯上首字母
   大写，
   构造函数和普通函数的区别就是调用方式的不同，普通函数直接调用，构造函数需要
   使用new关键字来调用
   构造函数的执行流程:
    1. 立刻创建一个新的对象
    2. 将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
    3. 执行函数中的代码
    4. 将新建的对象作为返回值返回
   一个构造函数创建的对象，称为一类对象，将通过一个构造函数创建的对象，称为
   该构造函数的实例.

** 检查对象的实例
   instanceof可以检查一个对象是否一个类的实例
   语法:
        对象，instanceof 构造函数
   如果是，则返回true,否则返回false
   dog insstanceof Person

** this情况
   1. 函数形式调用时，this是window,
   2. 当以方法形式调用时，谁调用方法this就是谁
   3. 当以构造函数形式调用时，this就新创建的对象

** 函数数在全局作用域
   污染了全局作用域的命名空间，而且定义在全局作用域中也很不安全
   元素prototype 我们所创建每一个函数，解析器都会向函数中添加属性prototype(无论)
   构造函数和普通函数，这个属性对应一个对象，这个对象就是我们所谓的原型对象
   prototype保存原型对象的地址，每一个函数都有原型对象
   当函数通过构造函数调用时，所创建的对象中都会有一个隐含的属性。指向该构造函数
   的原型对象
   function MyClass(){}
   var mc=new MyClass(); 此时MyClass()的隐含属性和上面prototype的指向的一样
   - 注意： 可以通过_proto_来访问该属性
*** 原型对象
    相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以
    将对象中共有的内容，统一设置到原型对象中
    当我们访问的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果
    没有，则会去原型对象中寻找，如果找到则直接使用
    可以将公共属性都保存到公共的隐含属性中
    Myclass.prototype.a=123;
    这样不会影响到全局作用域，也可以使每个对象都具有这些属性和方法
    使用in检查对象是否含有某个属性时，如果对象中没有但是原型中有，也会返回true

    - 可以使用对象hasOwnproperty()来检查对象自身中是否含有该属性
      使用该方法只有对象自身中含有属性时，才会返回true
    - 原型对象也是对象，它也有原型，当我们在使用对象的属性或方法时，会先在自身
      中寻找，自身中如果有，如果没有，则去原型对象中寻找，则使用，如果没有则去
      原型的原型中寻找,直到找到Object对象的原型
      mc.__proto__.__proto__.hasOwnProperty("hasownproperty")
** toString
  当我们直接在页面中打印一个对象时，事件上是输出的对象toString()方法的返回值
  如果在输出对象时不输出[Object object], 可以为对象添加一个toString()方法
  per.toString=function(){
  return "返回语句";
  }
  也可以修改原型的toString
  per.prototype.toString(){
   return "Person name="+this.name++" age="+this.age;
  }

* 函数的方法
**  call()和this
**  调用函数时传递的隐含参数
    1. 函数的上下文对象this
    2. 封装实参的对象arguments
       - arguments是一个类数组对象（但是不是一个数组）,它也可以通过索引来操作数据,
         也可以获取长度
       - 在调用函数时，我们所传递的实参都会在arguments中保存
       - arguments.length可以用来获取实参的长度
       - 我们即使不定义实参。也可以通过arguments来使用实参
         arguments[0] 表示第一个实参
         arguments[1] 表示第二个实参
       - 它里边有一个属性叫做callee, 这个属性对应一个函数对象，就是当前正在执行
    SCHEDULED: <2021-09-22 Wed>
   - 函数对象的方法，需要通过函数对象来调用
   - 当对函数调用call()和apply()都会调用执行
   - 在调用call和apply()可以将一个对象指定为第一个参数
     fun.apply(obj),那么这个对象将会成为函数执行时的this.可以用来指定函数
     执行时的this,
   - call()方法可以将实参在对象之后依次传递
   - apply()方法需要将实参封装到一个数组中统一传递
     fun.apply(obj,[2,3]) fun.call(obj,2,3)
   - this的情况:
     1. 以函数的形式调用时，this永远都是window
     2. 以方法的形式调用时，this是调用方法的对象
     3. 以构造函数的形式调用时，this是新创建的对象
     4. 使用call和apply调用时，this是指定的哪个对象

* gc(垃圾回收)
  - 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生一些垃圾，这些
    垃圾过多以后
  - 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾
  - 当一个对象或属性对它进行引用，我们将永远无法操作该对象，此时这种对象就是
    一个垃圾,这种对象会占用过多的内存空间，导致程序运行变慢，所以这种垃圾必须
    进行清理
  - 在JS中拥有自动的垃圾回收机制，会自动将垃圾对象从内存中销毁，我们不需要也
    不能进行垃圾回收的操作
  - 我们需要做的只是将不在使用的对象设置为null即可
* 包装类
** 基本介绍
   在JS中为我们提供了三个包装类，通过三个包装类可以将基本数据类型的数据转换为对象
   String()
   - 可以将基本数据类型字符串转换为String对象
   Number()
   - 可以将基本数据类型的数值转换为Number对象
   Boolean()
   - 可以将基本数据类型的布尔值转换为Boolean对象
   var num=new Number(1);
   var str=new String("hello");
   var bool=new Boolean(true);
   基本对象比基本数据类型更加强大
   -- 但是注意，我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型
   的对象，在做一些比较时，可能会带来一些不可预期的结果
   - 方法和属性之前添加给对象，不能添加给基本数据类型
     当我们对一些基本数据类型的值去调用属性和方法时,浏览器会临时使用包装类将其
     转换为对象，然后在调用对象的属性和方法. 调用完以后，在将其转换为基本数据类型
     s.hello="你好";
     临时将字符串转换为字符串对象， 添加完以后，又变为基本数据类型，属性销毁,
     所以无法读取
     注意： 此种数据类型转换,一般在底层使用

* 字符串的方法
** 简单介绍
   在底层字符串是以字符数组的形式保存的
   ['H','e','o']
** 方法
   length属性
   - 可以用来获取字符串的长度
   charAt()
   - 返回指定位置的字符
   - 可以返回字符串指定位置的字符
   charCodeAt()
   - 返回指定位置字符的Unicode编码
     str.charCodeat(0
   fromCharCode()
   - 可以根据字符编码去获取字符
     String.fromCharCode(20015) 中
   concat()
   - 可以用来连接两个或多个字符串
   indexof()
   - 该方法可以检索一个字符串中是否含有指定内容
   - 如果字符串中含有该内容，则会返回其第一次出现的索引
   - 没有找到指定的内容，则返回-1
   - 可以指定第二参数，指定开始查找的位置
   lastIndexOf()
   - 该方法的用法和indexOf()一样
        不同的是indexOf是从前往后找
        而lastIndexOf是从后往前找
   - 也可以指定开始查找的位置
   slice()
   - 可以从字符串中截取指定的内容
   - 不会影响原字符串，而是将截取到的内容返回
   - 参数:
        第一个，开始位置的索引(包括开始位置)
        第二个，结束位置的索引(不包括结束位置）
     - 如果省略第二个参数，则会截取后边所有的
     - 也可以传递一个负数作为参数，负数的话会从后边计算
     substring()
   - 可以用来截取一个字符串，可以slice类似
   参数:
     - 跌一个，开始截取位置的索引(包括开始位置)
     - 第二个，结束位置的索引（不包括结束位置）
     - 不同的是，这个方法不能接收负值作为参数，如果传递了一个负值，则默认
       使用0
     - 而且它还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换
    substr()
    - 用来截取字符串
    - 参数:
      1. 截取开始位置的索引
      2. 截取的长度
    split()
    - 将一个字符串拆分为一个数组
    - 如果传递空串作为参数，则会将每个字符都作为一个元素
    参数:
      - 需要一个字符串作为参数
        str.split(",") 根据,(逗号)拆分元素
    toLowerCase()
    - 把字符串转换为小写
    toUpperCase()

* DOM（Dcoument Object Model）
** html操作
*** 基本介绍
   * DOM 文档对象模型
   * JS中通过DOM来对HTML文档进行操作，只要理解了DOM就可以随心所欲的操作WEB页面
   * 文档
     - 文档表示的就是整个的HTML网页文档
   * 对象
     - 对象表示将网页中的每一个部分转换为一个对象
   * 模型
     - 使用模型来表示对象之间的关系，这样方便我们获取对象

*** 节点的使用
    var btn = document.getElementById("btn");
    //修改按钮的文字
    btn.innerHTML="i am Button";
*** 节点的基本介绍
    浏览器已经为我们提供文档节点对象这个对象是window属性,可以在页面中直接使用,
    文档节点代表的是整个网页
   * 节点Node,是构成我们网页的最基本的组成部分，网页中的每一个部分都可以
     称为是一个节点
   * 比如: html标签，属性，文本，注释，整个文档等都是一个节点.
   * 虽然都是节点，但是实际上我们的具体类型是不同的。
   * 比如：标签我们称为元素节点，属性称为属性节点，文本称为文本节点，文档称为
     文档节点
   * 常用节点分为四类
     - 文档节点: 整个Html文档
     - 元素节点: HTML文档中的HTML标签
     - 属性节点: 元素的属性
     - 文本节点: HTML标签
*** 节点的属性
    |          | nodeName  | nodeType | nodeValue |
    | 文档节点 | #document |        9 | null      |
    | 元素节点 | 标签名    |       11 | null      |
    | 属性节点 | 属性名    |        2 | 属性值    |
    | 文本属性 | #text     |        3 | *文本内容 |
*** 事件
    - 事件，就是文档或浏览器窗口发生的一些特定交互瞬间.
    - JavaScript与HTML之间的交互是通过事件实现的。
    - 对于Web应用来说，有下面这些代表性的事件
      事件： 点击某个元素，将鼠标移动到某个元素上方，按下键盘某个键，等等
    - 我们可以在事件对于的属性中设置一些代码，这些事件被触发时，这些代码将会
      执行
      <button id="btn" onclick="alert('讨厌,你点我干嘛!)"><button>
      (这种写法我们称为结构的耦合，不方便维护，不推荐使用)
    - 可以按钮的对应事件绑定处理函数的形式来响应事件,这样事件被触发时，其对应的
      函数将会被调用
      btn.onclick=function(){
        alert("你还点");
      };

*** 事件的使用
    - 浏览器 在加载一个页面时，是按照自上而下的顺序加载的，读取一行加载一行，
      如果将script标签写到页面的上边，在代码执行时，页面还没有加载
    - 将js代码编写到页面的下部，确保页面加载完之后，执行js代码
    - onload事件会在整个页面加载完成之后才会触发,可以将onload事件绑定给window,
      该事件对应的响应函数，将在页面加载之后执行
      window.onload=function(){
      var btn=document.getElementById("btn");
      btn.onclick=function(){
        alert("hello");
        }
      }
    - 如果追求性能，后加载后执行;

*** 获取元素节点
    * 通过document对象调用
      1. getElementById()
         - 通过id属性获取一个元素节点对象
      2. getElementsByTagName()
         - 通过标签名获取一组元素节点对象
      3. getElementsByName()
         - 通过name属性获取一组元素节点对象

*** 获取元素节点的子节点
    1. getElementsByTagName()
       - 方法 返回当前节点的指定标签后代节点
              此方法在指定元素的后代中查询
    2. childNodes
       - 属性 表示当前节点的所有子节点
    3. children
       - 属性 在除了Ie8以上浏览器中返回元素
    4. firstChild
       - 属性 表示当前节点的第一个子节点
       - 包括空白
    5. firstElementChild
       - 属性 获取当前元素的第一个子元素
    6. lastChild
       - 属性 表示当前节点的最后一个子节点
    7. parentNode
       - 属性 获取当前节点的父节点
    8. previousSibling previousElementSibling
       - 属性 表示当前节点的前一个兄弟节点
       - 属性 获取前一个兄弟元素 ie8以下不支持
    9. nextSibling
       - 属性 表示当前节点的后一个兄弟节点
    10. innerText
        - 属性 获取到元素的文本内容，与innerHTML不同的是会自动去掉标签
    11. innerHTML
        - 属性 获取的元素内部的内容
    12. 元素.value
        - 获取文本框的value属性值

*** COMMENT dom节点查询的其它方法
    SCHEDULED: <2021-10-01 Fri>
    - 在document中有一个属性body，它保存的是body的引用
      var body=document.body;
    - document.documentElement保存的是html根标签
      var html=document.documentElement;
    document.all
    - 代表页面中所有的元素
    all =document.getElementByTagName("*");
    - 根据class属性查询一组元素节点对象
      var box1=document.getElementsByClassName("box1");
    - document.querySelector()
      - 需要一个选择器的字符串作为参数，可以根据CSS选择器来查询元素节点对象
      - 可以在ie8中使用
      - 总会返回唯一的元素，如果满足条件的为多个，则只会返回第一个
    - document.querySelectorAll()
      - 即使符合条件的元素只有一个，也会返回数组
      - 可以根据css选择器来查询元素节点对象
** dom对象方法
*** 增加删除修改
    使用innerHTML也可以实现增删
    父节点.innerHTML="<li>广州</li>";
    - 缺点，修改过程太复杂（电脑），不建议使用
      推荐
      li.innnerHTML="广州";
    1. appendChild() 把新的子节点添加到指定节点
    2. removeChild() 删除子节点
    3. replaceChild() 替换子节点
    4. insertBefore() 插入子节点
    5. createAttribute() 创建属性节点e
    6. createElement() 创建元素节点
    7. createTextNode() 创建文本节点
    8. getAttribute 返回指定的属性值
    9. setAttribute() 把指定的值设置或者修改为指定的值

*** 超链接
    超链接会在跳转后取消默认
    行为
    1. 通过在响应函数返回false 可以取消默认行为, return false
    2. 或者可以在链接中<a href="javascript:;"></a> 来取消默认行为
*** 响应函数的执行问题
    for循环会在页面加载完成之后立即执行，而响应函数会在超链接被点击时才执行，
    当响应函数执行时，超链接早已执行完毕，所以当单击时，i的值为为最大，而响应
    函数点击时才会执行
    #+begin_export html
    <script>
    for(var i=0;i<allA.length;i++){
      myfun.onclick=function(){alert("hello")};
    }
    </script>
    #+end_export

** css操作
*** 修改读取内联样式
    通过js修改元素的样式
    语法: 元素.style.样式名=样式值(此处样式值应该为字符串)
    注意 background-color -在js中是不合法
         需要将此种名称修改为驼峰命名法，去掉-号将-号后的字母大写
    我们通过style属性设置的样式都是内联样式，所以通过js修改的样式往往会立即显示,但是
    如果在样式设置为!important,则此时样式会有最高的优先级

    读取元素的样式
    语法 元素.style.样式名
    通过style属性读取和设置的都是内联样式，无法读取样式表中的样式
*** 修改和读取当前样式
    语法 元素.currentStyle.样式名 (此方法只有ie8浏览器支持)
    它可以用来读取当前元素正在显示的样式，如果当前元素没显示该样式，则获取它的 默认值
    在其它浏览器中可以使用

    getComputedStyle()这个方法获取元素当前的样式（不支持ie8以下的浏览器）
     这是window的方法，可以直接使用
    需要两个参数
      第一个： 需要获取样式的元素
      第二个:  一般传递一个伪元素null
   定义一个函数，用来获取当前元素的指定样式
   #+begin_javascript
   function getStyle(obj,name){
   if(window.getComputedStyle) //变量没找到会报错，属性不会
       return getComputedStyle(obj,null)[name];
   else{
       return obj.currentStyle[name];}
   }
   #+end_javascript
   obj 要获取的样式的元素
   name 要获取的样式名
*** CANCELLED 其它样式相关的属性
    CLOSED: [2021-10-02 Sat 03:28]
    以下属性返回的只是数字，不带有px
    1. element.clientHeight 返回元素的可见高度
       element.clientWidth 返回元素的可见宽度
       - 会获取元素的高度，宽度，包括内容区和内边距,这些属性都是只读，不能修改
    2. element.offsetWidth
       element.offsetHeight
       - 获取整个元素的可见的宽度和高度（如果有滚动条，则是去除滚动条之后的距离）
       - 包括内容区，内边距，边框
    3. element.offsetParent
       - 定位当前元素的父元素
       - 会获取到当前元素最近的开启了定位的祖先元素
         如果所有祖先元素都没有开启定位，则返回body
       .offsetLeft
       - 当前元素相对于其定位父元素的水平偏移量
       .offsetTop
       - 当前元素相对于其定位父元素的垂直偏移量
    4. element.scrollHeight 返回固定元素的整体高度
       element.scrollwidth 返回固定元素的整体宽度
    5. element.scrollTop 返回元素垂直滚动条的滚动距离
       element.scrollLeft 返回元素水平滚动条的滚动距离
    6. 元素.scrollHeight-元素.scrollTop=元素.clientHeight
       当满足此等式时，说明垂直滚动条滚动到底了
       元素.scrollWidth-元素.scrollLeft=元素.clientWidth;
       如果为表单项添加disabled属性，则表单项会处于不可用状态
       element.onscroll 会在元素的滚动条滚动时触
** 事件对象
   - 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数，
     在事件对象封装了当前事件相关的一切信息，比如：鼠标座标，鼠标滚轮滚动的方向
   - 在ie8中，响应函数被触发时，浏览器不会传递事件对象，在ie8以下浏览器中，是将事件对象
     作为window对象的属性保存
     window.event.clientX
   - clientX指定鼠标相对于可见窗口的座标
     pageX
     pageY获取相对于当前页面的偏移量(但是在ie8中不支持)
   - chrome认为滚动条是body的
     firefox等认为浏览器的滚动条是html
     document.body.scrollTop || document.documentElement.scrollTop
** 事件的冒泡
   所谓的事件冒泡。指代事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件
   也会被触发
   在开发中，冒泡都是有用的
   event.cancelBubble=true 取消事件冒泡
** 事件的委派
   我们希望，只绑定一次事件，即可应用到多个事件上，即使元素是元素是后添加的，我们可以
   尝试将其绑定给元素共同的祖先元素
   - 这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而触发祖先元素的响应函数来
   处理事件
   - 事件委派是利用了冒泡，通过委派可以减少事件的绑定的次数，提高程序的性能
   - event.target 返回触发此事件的对象
     if(event.target.className=="classname")
** 事件的绑定
*** 基本介绍
    1. 使用(对象.事件)只能同时绑定一个响应函数，不能同时绑定多个，后面的会覆盖前面的
    2. addEventListener("click",fun,false) 此方法不支持ie8以上浏览器
       - 通过此方法可以为元素绑定响应函数
       - 参数
         1. 事件的字符串，不要on ("click")
         2. 当事件触发时，会被调用的函数
         3. 是否在捕获阶段触发事件，一般都会传入false
    3. 这样当事件被触发时，响应函数会按照函数的绑定顺序执行
    4. 在ie8中可以使用attachEvent来绑定事件
       attachEvent()
       - 参数:
         1. 事件的字符串，要on "onclick"
         2. 回调函数
       - 这个方法也可以为一个元素绑定多个事件，不同的是它不是按照绑定顺序执行
         执行顺序与addEventListener()相反

*** bind 为事件绑定响应函数
    #+begin_export html
    z    <script>
      function bind(obj,eventStr,callBack){
      if(obj.addEventListener)
      obj.addEventListener(eventStr,callBack,false);
      else{
        obj.attachEvent("on"+eventStr,function(){
        //由obj调用的
        callBack().call(obj);
        });
      }
    }
    </script>
    #+end_export
** 事件的传播
   1. 事件应该是由内向外传播,当事件触发时，应该先触发当前元素上的事件，然后再向
      当前元素的祖先元素上传播,也就说事件应该在冒泡阶段执行
   2. 事件应该由外向内传播，也就是当事件触发时。应该先触发当前元素最外层祖先元素的
      事件，然后向内传播给后代元素（事件的捕获阶段)
   3. w3c综合以上方案，将事件的传播分成三个阶段
      1. 捕获阶段
         - 在捕获阶段从最外层的祖先元素向目标元素进行事件的捕获,但是默认此时不会
           触发事件
      2. 目标阶段
         - 事件捕获到目标元素，捕获结束后，开始在目标元素上执行事件
      3. 冒泡阶段
         - 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件
      4. 如果希望在捕获阶段就触发事件，可以将addEventListener的第三个参数
         设置为true

** 拖拽
   当我们拖拽一个网页中内容中，浏览器会默认去搜索引擎中搜索内容此时会导致拖拽功能的异常
   这个是浏览器提供的默认行为，可以通过return false,来取消此类行为,但是此方法对于ie8
   不起作用
   当调用一个setCapture方法时，这个元素会把下一次所有鼠标按下相关的事件捕获到自身上，

** 鼠标滚轮的事件
   onmousewheel 鼠标滚轮滚动的事件，会在滚轮滚动时触发
   - 注意在火狐中需要使用DOMMouseScroll 来绑定事件，而且该事件需要通过
     addEventListener
   event.wheelDelta 获取鼠标滚轮滚动的方向 向上正值，向下滚负值
   event.detail 在火狐中使用此属性来获取鼠标滚轮滚动方向
   当滚轮滚动时，，如果浏览器有滚动条，滚动条会随之滚动，这是浏览器的默认行为，则
   可以取消浏览器的默认行为，当利用addEventListener绑定响应函数，则
   不能使用return false
   则需要event.preventDefault来取消默认保存行为，但是ie8不支持

** 键盘的事件
   onkeydown
   onkeyup
   - 当键盘按键被松开或者按下，键盘事件一般都会绑定到一些可以获取到焦点的事件，
   - 对于onkeydown如果一直按着某个按键不松手，则事件会一直触发
   - 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他会非常的
     快。这种设计是为了防止误操作的产生
   keyCode
   - 可以通过keyCode来获取按键的编码
   - 通过它可以判断哪个按键按下
     除了keyCode，事件中还提供了其他属性，
   - altKey ctrlKey shiftKey
     用来判断哪个按键被按下，按下则返回true,否则返回false
   注意： 在文本框中输入内容，属于onkeydown的默认行为，如果在onkeydown中取消
   默认行为，则输入的内容，不会出现在文本框。
   使文本框不能输入数字
   if(event.keyCode>=48 && event.keyCode<=57)
   return false;
   左上右下 37 38 39 40

* BOM浏览器对象模型
** 基本定义
   - BOM可以通过js来操作浏览器
   - BOM可以使我们通过js来操作浏览器
   - 在BOM中为我们提供了一组对象，用来完成浏览器的操作
   - BOM对象
     Window
     - 代表的是整个浏览器的窗口,同时window也是网页中的全局对象
     Navigator
     - 代表当前浏览器的信息，通过该对象可以来识别不同的浏览器
     Location
     - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者
       操作浏览器跳转页面
     History
     - 代表浏览器的历史记录，通过该对象，可以操作浏览器的历史记录
     - 由于隐私的原因，该对象不能获取到具体的历史记录，只能操作浏览器向前
       或者向后翻页，而且该操作只在当次访问时有效
     Screen
     - 通过该对象可以获取到用户的显示器的相关信息
   - 这些BOM对象都是作为window对象的属性保存的，也可以直接使用
** Navigator
   appName
   - 获取浏览器的名称,通过该对象来识别不同的浏览器
   - 由于历史元素，Navigator对象中的大部分属性都不能帮助我们识别浏览器
   userAgent
   - 一般只会使用userAgent来判断浏览器的信息,这个字段中有包含有描述浏览器信息
     的内容，不同的浏览器会有不同的userAgent
   - ie11中，已经将微软和ie相关的标识已经去除了，基本上已经不能通过userAgent
     来识别浏览器是否是ie
   - 可以通过浏览器中特有的对象，来判断浏览器的信息
     ActiveXObject 但是现在转换布尔值为false;
     if("ActiveXObject" in window) 检查对象中是否包含某个属性
** history
   - 可以用来操作浏览器向前向后翻页
   - history.length
     返回当前访问的链接数量
   - back()
     可以用来回退到上一个页面，和浏览器的回退按钮一样
   - forward()
     - 可以跳转下一个页面，作用和浏览器的前进按钮一样
   - go()
     - 用来跳转到指定的页面
     - 它需要整数作为参数
       - 1 表示向前跳转一个，相当与forward
       - -1 表示向后跳转一个页面
** Location
   如果直接打印location，可以获取到地址栏的信息，也就是完整路径，而且是当前页面的
   完整路径，如果直接location属性修改为一个完整的路径，或相对路径，则页面会自动
   跳转到该路径，并且会生成相应的历史记录
   属性:
   方法：
    assign()
    - 跳转到其它页面，作用和直接修改location一样
    reoload()
    - 重新加载当前文档,作用和刷新按钮一样
    - 如果在方法中传递true作为参数，则会强制刷新缓冲，刷新页面
    replace()
    - 可以使用一个新的页面替换当前页面,调用完毕，也会跳转页面,但是不能回退

* 定时器
** 简介
   js程序执行的速度是非常快的，如果希一段程序，每间隔一段时间，执行一次，可以定时
   调用
   clearIterval()
   - 可以用来关闭一个定时器,需要定时器的标识作为参数
   clearTimeout()
   - 关闭延时调用
   setInterval()
   - 定时调用，可以将一个函数，每隔一段时间，执行一次
   - 参数：
     - 回调函数，该函数被每隔一段时间调用一次
     - 每次调用间隔的时间 默认单位ms
   - 返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
   setTimeout()
   - 设置延时调用，延时调用和定时调用的功能可以相互代替
** 注意
   如果设置点击按钮来开启定时器，点击多次就会开启多个定时器，这就导致图片切换过快,
   并且我们只能关闭最后一次的定时器,所以在开启定时器之前，将上一个定时器关闭
** 延时调用
   开启一个定时器，延时调用一个函数不马上执行，而是隔一段时间以后再执行,而且只会
   执行一次，定时调用会执行多次
* 类的操作
** 简介
   通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重写渲染一次页面，这样
   执行的性能比较差，而且这种形式，当我们要修改多个样式时，不太方便.
   我希望一行代码同时修改多个样式
   - 我们可以通过元素的class属性来间接的修改元素的class属性
   - 这样浏览器只需要重新渲染页面一次，性能比较好
   - 并且这种方式，可以使表现和行为进一步分离
   - 元素.className+=" class" 可以将多个类应用到同一个元素上
   - 定义一个函数，用来向一个元素中添加指定的属性值
* json
  - js中的对象只有JS自己认识，其他语言都不认识
  - JSON是一个特殊格式的字符串，这个字符串可以被任意的语言所识别
    并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
  - JSON
    - Javascript Object Notation JS对象表示法
    - JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号
    - JSON的分类
      对象{}
      数组[]
    - JSON中允许的值
      1. 字符串
      2. 数值
      3. 布尔值
      4. null
      5. 对象
      6. 数组
  - 将json字符串转化为字符串的对象
    在JS中，为我们提供一个工具类，就叫json
    JSON.parse();
    可以将JSON字符串转换为js对象
  - JSON.stringify()
    - 可以将一个JS对象转换为JSON字符串
    - 需要一个js对象
  JSON这个对象在ie7及其以下浏览器定义时会报错
   eval()
   - 这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回
   - 如果使用evel()执行的字符串中含有{},它会将{}当成代码块
     如果不希望将其当成代码块解析，则需要字符串前后各加一个()
     eval("("++str++")")
     它有安全隐患，过于强大的权限

     
