* 队列
** 概述
1. 队列先进先出，每次插入时，插入到元素的最后，当取出时，先取出元素的第一个。
* 栈
** 概述
1. 队列先进后出，每次进行插入时，插入到最后的元素，每次取出时，取出最后的元素
2. 先入后出(FILO-First-In-Last Out)的有序列表
3. 栈(stack)是一种插入和删除只能在线性表的同一端进行的限制性线性表，为允许插入和插入
   的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底。
4. 先放入的元素在相对接近栈底，后放入的元素相对接近栈顶。删除时，后放入的元素最先删除，
   先放入的元素后删除。
** 栈实现综合计算器（中缀表达式）
*** 中缀表达式
**** 概述
中缀表达式是一个通用的算术或逻辑公式表达方法，操作符是以中缀形式处于操作数的中间，中缀表达式
不容易被电脑解析逻辑优先顺序。在中缀表达式中，括号是必须的，计算机必须用括号将操作符和对应的操作
数括起来，用于指示计算的顺序.
不允许两个操作符中间没有运算符，也不允许两个运算符中间没有操作符
**** 步骤
求值6+1-2*3+1
| 读取元素 | 解析后的表达式 | 说明 |
|        6 |              6 |      |
|        + |             6+ |      |
|        1 |            6+1 |      |
|        - |             7- |   1) |
|        2 |            7-2 |      |
|        * |           7-2* |   2) |
|        3 |          7-2*3 |   3) |
|        + |           7-6+ |   4) |
|        1 |              1 |   5) |
|          |              2 |      |
首先将数字压入栈中
1) 当连续将两个操作符和一个运算符压入数字栈和操作符栈中以后，看到第二个运算符，第二个运算符不大于第一个，所以从栈中推出两个数，运算符栈中提取一个，进行运算,
2) 再次看到运算符，因为乘的优先级高，所以不进行运算
3) 看到乘法后的操作数，将其压入数字栈，乘法已经被压入操作符栈
4) 再次看到+，优先级不高于乘法，将乘法取出，取出两个操作数进行运算，
5) 到达值的末尾以后，依次取出一个运算符和两个操作数进行运算，最后得到结果
**** 程序实现
1) 首先建立一个栈，需要的功能有，入栈，出栈，查看栈的第一个数，运算符优先级，是否是运算符
2) 开始创建栈，一个操作数栈，一个运算符栈,一些需要用到的变量,保存数字，以及参于运算的
3) 遍历整个表达式
   1. 如果是运算符,运算则判断符栈是否为空
      1. 运算符栈为空，则将操作符压入到栈中
      2. 如果运算符栈不为空，则碰到的运算符于栈顶运算符进行比较，
         1. 如果当前运算符大于栈顶运算符，则将当前运算符压入栈中，不进行运算
         2. 如果当前运算符小于等于栈顶运算符，则将栈顶运算符取出，再从操作数栈取出
            两个数，一起计算
   2. 如果操作数，则需要继续向下读取，直到碰到不是数的值，然后将数进行拼接
      最后将操作数，压入栈中
      1. 如果char已经是最后一个字符，则直接进行入栈
      2. 如果连接之后碰到运算符，则直接进行入栈
   3. 如果为空，直接入符号栈
   4. 此时索引+1，判断是否已经扫描到了表达式的最后，最后则break;
   5. 最后将符号栈和操作数栈的元素取出，依次进行运算
**** 程序实现优化
1. 编写栈，并且加入扩展功能,运算符优先级，计算方法，判断是否运算符等。
2. 定义基本的变量，用于扫描，接收字符，栈中运算符及数字，运算结果的变量。创建数字栈和符号栈。
3. 开始遍历，遍历直到表达式的末尾
   + 碰到符号
	 * 符号栈为空 直接压入栈中
	 * 符号不为空
	   1. 符号栈符号是左括号'('或者符号栈符号的优先级小于当前符号的优先级,则直接将当前符号压入栈中
	   2. 当前符号优先级小于等于符号栈中符号的优先级时，提取符号栈中符号，并且从数字栈中提取两个数字进行运算。将运算结果压入数字栈，当前符号压入符号栈
	   3. 如果当前符号是右括号‘）’ ，则将符号栈和数字栈中的数字符号取出，运算，结果放入数字栈，直到符号栈栈顶元素为右括号，停止计算，弹出右括号
		  #+begin_src java
			 case -1 ->{
                           while (opers.peek()!='('){
                               num1=nums.pop();
                               num2=nums.pop();
                               oper=opers.pop();
                               result=opers.cal(num1,num2,oper);
                               nums.push(result);
                           }
                           opers.pop();
                     } // ')' 优先级为-1
		  #+end_src
   + 碰到数字
	 1) 将数字拼接到保存数字的字符串
	 2) 然后判断数字是否到了末尾
		+ 末尾： 直接将数字压入数字栈中
		+ 非末尾： 如果下一位是符号，则直接保存数字的字符串转化为数字，并且压入栈中,否则，继续遍历循环
4. 遍历结束，将符号栈元素和数字栈中元素取出进行运算，直到符号栈空，数字栈中的元素只有一个
   #+begin_src java
	  while (!opers.isEmpty()) {
            num1 = nums.pop();
            num2 = nums.pop();
            oper = opers.pop();
            result = opers.cal(num1, num2, oper);
            nums.push(result);
        }
   #+end_src
* 查找
** 二分查找
** 插值查找
** 裴波拉契查找算法
1. 将mid设置为mid=low+F(K-1)-1
2. 对F(K-1)-1的理解
   1. 由裴波拉契数列F(k)=F(K-1)+F(K-2)的性质,可以得到
	  F(k)-1=(F(K-1)-1)+(F(k-2)-1)+1,该式说明，只要顺序的数量等于F(k)-1,就可以分为
	  F(k-1)-1和F(k-2)-1两部分
   2. 类似的，每个字段可以用相同的方式进行分割
   3. 可以将原来的数列增加到F(k)-1
	  #+begin_src java
		public 
	  #+end_src
* 树
** 为什么需要树
链表和数组存储方式
1. 数组在插入时，需要移动元素，查询时必须按照顺序查找。
2. 当数组容量到达极限时，需要扩容，并且复制的旧的数据到新的数组中
3. 数组的优点是方便查找元素，但对于插入不友好
4. 链式存储，对于数据的储存方式有优化
树存储方式的分析
1. 如果将任意节点作为根节点
2. 比根节点小的放到左边，比根节点大的放到右边。
3. 如果要树的中间节点，将该节点的右子节点连接到该节点的父节点
   然后将左子节点放在
** 树
+ 满二叉树
  结点总数2^n-1,所有的叶子节点都在最后一层
+ 完全二叉树
  所有的叶子节点都在最后一层或者倒数第二层，倒数蒂一层的叶子
  节点在左边连续,倒数第二层的叶子节点在右边连续，称为完全二叉树
** 遍历
+ 前序遍历
  先输出父节点，再输出左子树和右子树
+ 中序遍历
  先遍历左子树，再输出父节点，再遍历右子树
+ 后序遍历
  先遍历左子树，再遍历右子树，最后输出父节点
*** 遍历实现（前序遍历）
1. 创建一颗二叉树.
2. 前序遍历
3. 先输出当前节点（初始）
4. 判断当前节点的左子节点是否为空，不为空，则输出左子节点
5. 判断当前节点的右子节点是否为空，不为空，则输出右子节点
** 顺序存储二叉树
*** 概述
- 数组存储方式和树的存储方式可以相互转换，即数组可以转换为树，树也可以转换为数组。
- 要求以数组的方式存储二叉树
- 在遍历时，仍然可以以前序遍历，中序，后序遍历的方式完成节点的遍历
*** 特点
+ 顺序存储二叉树的特点
  1) 通常只考虑完全二叉树
  2) 第n个元素的左子节点为2*n+1
  3) 第n个元素的右子节点为2*n+2
  4) 第n个元素的父节点为(n-1)/2
** 线索化二叉树
*** 线索化二叉树
问题
1. 当对二叉树进行遍历时，左右节点的指针并没有完全利用
2. 希望充分利用各个节点的左右指针，让各个节点可以指向自己的前后节点，怎么办
解决
1. 利用二叉列表的空指针域(n+1[2n-(n-1)])个空指针域
** 堆排序
*** 概述
1) 堆排序是一种选择排序，它的最好，最坏，平均时间复杂度为O(nlogn),它也是不稳定排序
2) 堆是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右节点的值，称为大顶堆，
  注意：堆对左右节点的大小关系没有要求
3) 每个节点的值小于或等于其左右节点的值称为小顶堆。
4) 一版升序采用大顶堆，降序采用小顶堆
*** 基本思想
1. 将待排序序列造成一个大顶堆
2. 此时，整个序列的最大值就是堆顶的根节点
3. 将其与末尾元素进行交换，此时末尾为最大值
4. 然后将剩余n-1个元素重新塑造为一个堆，这样会得到n-1个元素的次小值，如此反复执行，就能得
   到一个有序序列
*** 实现步骤
** HuffmanTree
1) 给定权值作为n个叶子节点，构造一颗二叉树，若树的带权路径长度
   达到最小，那这样的二叉树最优二叉树，也叫HuffmanTree
2) HuffMan树是指代权路径长度最小，权值最大的节点离根节点最近，确保
   WSL带权路径长度最小
3) 创建huffmanTree
   - 首先遍历文本，并且计算每个字符出现的频率，然后根据其出现的频率来进行
     排序。频率越高的树越接近树的顶端。
   - 然后将节点按照频率排序压入栈中(priorityQueue)中
   - 将栈中的节点依次取出两个，设置为left and right Node,将其频率相加
     作文父节点频率来将父节点压入栈中
** BST二叉排序树
*** 概述
1. 要求树的左子节点比右子节点值的要小。如果值相同，可以任意选择位置
*** 二叉树的添加
1. 首先判断需要添加的节点是否比当前节点大
2. 如果比当前节点大 则判断当前节点右子树是否为空
   - 右子树为空，则添加当前节点到右子树
   - 不为空，则递归到右子树的节点是否可以添加
3. 小的，则判断左子树是否为空
   - 为空，直接添加到左子树
   - 不为空，则继续递归左子树
*** 二叉树的删除
1. 删除叶子节点
   + 找到要进行删除的节点
   + 找到该节点的父节点，并且判断该目标节点是父节点的左子节点还是右子节点
   + 如果是左子节点，则将父节点的左子节点置空 
2. 删除只有一颗子树的节点
   + 找到要删除的节点
   + 找到目标节点父节点
   + 确定targetNode的子节点是左子节点还是右子节点
   + 如果targetNode有左子节点
     - 如果targetNode是parent的左子节点
       parent.left=target.left
     - 如果targetNode是parent的右子节点
       parent.right=target,left
   + 如果targetNode有右子节点
     - 如果targetNode是parent的左子节点
       parent.left=targetNode.right
     - 如果targetNode是parent的右子节点
       parent.right=targetNode.right
3. 删除有两颗子树的节点
   - 需要先找到要删除的节点
   - 找该节点的父节点
   - 找到目标节点的右子树,找到最小的节点
   - 用一个临时变量，将最小节点保存
   - 删除目标节点以后，将右子树的最小节点，赋给目标节点。
** 平衡二叉树
*** 概述
如果左子树全部为空，从形式上看，要像一个单链表。查询速度明显降低，不能
发挥排序树的优点
1. 平衡二叉树又叫平衡二叉搜索树，称为AVL结构，保证查询效率较高
2. 它是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右
   两个子树都是一课平衡二叉树，平衡二叉树的实现有红黑树，AVL,替罪羊树。
   Treap，伸展树等
*** 左旋转
1. 根据当前节点(子树高度相差的绝对值超过1)，创建一个Nnewnode
2. 将当前节点的左子树设置为newnode左子树，将当前节点的右子树
   new node。
3. 将当前节点设置为当前节点的值替换为右子树的值
4. 将当前节点的右子树设置为右子树的子树
*** 双旋转
1. 当符号右旋转的条件时
2. 如果它的左子树的右子树高度大于左子树的高度
3. 先对当前这个节点的左子树进行左旋转
** 多叉树
*** 问题
1. 二叉树需要加载到内存，如果二叉树节点少，没什么问题，但是二叉树节点很多，就存在以下问题
   1) 问题1: 去构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中，节点海量，构造二叉树时，速度
      有影响)
   2) 问题2:节点海量，会造成二叉树的高度很大，会降低操作速度
*** 概述
1) 在多叉树中，每个节点可以有更多的数据项，就是多叉树
2) 多叉树，通过重新组织节点，减少树的高度，能对二叉树进行优化
3) 2-3树
   - 3节点有两个数据项,下面有三个分支
   - 2节点有一个数据项 下面两个分支
4) B树
   - B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率
   - 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页面大小通常设置为4k）,
     每个节点只需要一次I/O就可以完全载入(预先从磁盘里读取数据)
   - 将树的度M设置为1024,在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树广泛应用于文件存储
     系统以及数据库系统中
*** 2-3树(简单B树结构)
**** 概述
1. 2-3树，所有的叶子节点都在同一层，（只要是B树都满足这个条件）
2. 有两个子节点的节点叫做二节点，二节点要么没有子节点，要么有两个子节点
3. 有三个子节点的节点叫做三节点，三节点要么没有子节点，要么有三个子节点
4. 2-3树是由2节点和3节点构成的树
   - 如果是三节点，要则该节点的左子节点，小于第一个数，中间子节点要大于当前节点第一个数，小于第二个，
     右子节点要大于当前节点的第二树
**** 构造2-3树
1. 以以下数列为准
   arr{16,24,12,32,14,26,34,10,8,28,38,20}
*** B-tree(Balance)
**** 介绍
1. B树的阶指代节点的最多子节点的个数，比如23树的阶是3，234树的阶是4
2. B-树的搜索从根节点开始，对节点内的关键字序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的子
   节点，重复，直到所对应的子指针为空，或已经是叶子节点
3. 关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据
4. 搜索有可能在非叶子节点结束
5. 其搜索性能等价于在关键字全集内做一次二分查找
*** B+树
**** 介绍
1. b+树只有在叶子节点时才会命中，其性能等价于在关键字集合内做一次二分查找
2. 所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点）。且列表中的关键字是有序的，
3. 不呢在非叶子节点命中
4. 非叶子节点相当于是叶子节点的索引，叶子节点相当于是存储数据的数据层
5. 更适合文件索引系统
6. B树和B+树适合不同的场合
*** B*树
**** 介绍
1. B*的兄弟索引之间有一个连接。B*树规定了非叶子节点的关键字的个数至少为(2/3)*M，即块的最低使用率2/3，而B+树
   的块的最低使用率为B+树的1/2

2. B*树的空间使用效率要更高
* 图
** 介绍
1. 图用来处理多对多的关系
2. 图的常用概念
   - 顶点(vertex)，顶点之间的连接没有方向 无向图
   - 边(edge)
     如果边带有权值的图也叫做网
   - 路径
   - 无向图
3. 图的表示方式
   1. 二维数组（邻接矩阵），链表表示（领接表）
   2. 领接矩阵
      对于n个顶点的图而言，矩阵是row和col表示的是1...n个点，然后矩阵中的0或者1表示联通，或者
      不联通
   3. 瓴接表
      邻接矩阵需要为每个表都分配n个边的空间，其实有很多功能并不存在，会对空间造成一定损失
      邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成
      (每个顶点，可以记录它可以跟多少个顶点相关联)
** 实现步骤
1. 存储顶点 ArrayList
2. 使用二维数组即矩阵来保存边与边之间的关系
** 图的深度优先遍历
*** 概述
图的遍历，即对节点的访问，一个图的节点很多，所以需要特定的访问策略
1. 深度优先遍历
2. 广度优先遍历
图的深度优先搜索
1) 深度优先遍历，从初始节点出发，初始访问节点可能有多个邻接节点，深度
   优先是访问第一个邻接节点，然后以这个被访问的邻接节点为初始节点，
   访问它的第一个邻接节点。每次在访问当前节点后首先访问当前节点的第一
   个邻接节点
2) 可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有
   邻接节点进行横向访问
3) 深度优先遍历需要递归
*** 具体算法步骤
1) 访问初始节点v.并标记节点v为已访问。
2) 查找节点v的第一个邻接节点w
3) 若w存在，则继续执行4，如果w不存在，则返回第一步，将从v的下一个节点
   继续
4) 若w未被访问，对w进行深度优先遍历递归(即把w当做另一个v,然后进行
   )步骤123
5) 查找节点v的下一个邻接节点，转到步骤3
** 图的广度优先遍历
*** 概述
1. 图的广度优先搜索（Broad First Search）。类似于一个 分层搜索
   的过程，广度优先遍历需要使用一个队列以 保持访问过节点的顺序，
   以便按这个顺序来访问这些节点的邻接节点
*** 广度优先遍历的算法步骤
1) 访问初始节点v并标记节点v为已访问
2) 节点v入队列
3) 当队列非空时，继续执行，否则算法结束(针对v节点的算法结束)
4) 出队列，取得队头节点u
5) 查找节点u的第一个邻接节点w
6) 若给点u的邻接节点w不存在。则转到步骤3。否则循环执行以下三个步骤：
   6.1 若节点w尚未被范围，则访问节点w并标记为已访问
   6.2 节点w入队列
   6.3 查找节点u的继w邻接节点后的下一个邻接节点w，转到步骤6
   

