* spring
** 概述
   - 体积小，轻量级开源的javaEE框架
   - 可以解决企业应用开发的复杂性
   - Spring有两个核心部分： IOC和Aop
     - IOC 控制反转,把创建对象的过程交给spring进行管理
     - Aop 面向切面,不修改源代码进行功能增强
   - Spring特点
     - 方便解耦
     - Aop编程支持
     - 方便程序的测试
     - 方便集成各种优秀框架
     - 降低JavaEEAPI的使用难度
     - java源码是精典学习规范
     - 方便进行事务操作
     - 降低API开发难度
** 案例
   1. 创建普通类
   2. spring配置文件
      spring中配置文件格式是(xml格式)
** IOC容器(inversion of Control)
*** IOC底层原理
    1) 控制反转, 把对象创建和对象之间调用的过程，交给Spring进行管理
    2) 使用IOC目的，为了耦合度降低
    3) IOC底层原理
       - xml解析，工厂模式，反射
	 1. 第一步: xml配置文件，配置创建的对象<bean id="beanName" class="path/to/bean"></bean>
	 2. 第二步: 有一个service类和dao类，创建工厂类,生产Dao对象
	    - 工厂类中的第一部分: class属性值，xml解析得到
	    - 通过反射创建对象,得到类的字节码文件
    4) spring提供IOC容器实现的两种方式: (两个接口)
       1) BeanFactory IOC开发器基本实现，是Spring内部的使用接口
       2) ApplicaitonContext BeanFactory接口的子接口,提供更多更强大的功能，一般
	  是由开发进行使用
       3) 区别： BeanFactory只会在获取（使用时候才会创建对象）创建，不会在加载时候创建对象,而在获取或者
	  使用时候才会创建对象
	  * 加载配置文件时候就会把配置文件对象进行创建
	  * 实际开发中，服务器启动时候创建对象，把耗时耗资源的过程交给服务器
	  * 第二个接口中的主要实现类
	    1. FileSystemXml... 对应的系统文件
	    2. ClassPathXml... 对应的Class路径
*** IOC操作Bean管理(基于xml)
**** 什么是Bean管理
     1. spring创建对象
     2. spring注入属性
**** Bean管理操作
     1. 基于xml创建对象
	#+begin_src xml
	  <bean id="user" class="com.asatuoyan.spring.User">
	    <constructor-arg name="oname" value="abc"></constructor-arg>
	    <constructor-arg name="address" value="chin"></constructor-arg>
	  </bean>
	  # id 唯一标识符
	  # class属性 类全路径（包类路径)
	  # 创建对象时候，默认执行无参数构造方法完成对象创建
	  # constructor-arg 有参数构造配置
	#+end_src
     2. 基于xml注入属性
	#+begin_src xml
	  <?xml version="1.0" encoding="utf-8"?>
	  #注入属性，基于对象创建的基础上完成
	  #使用set方法注入
	  #第二种方式，使用有参数构造进行注入
	  <property name="bname" value="hello"></property>
	  <property name="bauthor" value="world"></property>
	#+end_src
     3. beans
	#+begin_src xml
	  # p名称空间注入
	  <beans xmlns="http://www.springframework.org/schema/beans"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xmlns:p="http://www.springframework.org/schema/p"
		 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	    <bean id="book" class="com.asatuoyan.spring.Book" p:bname="en" p:author="anymous"></bean>
	  </beans>
	    # 进行属性注入，在bean标签中进行操作
	#+end_src
     4. 字面量
	1. null值
	   #+begin_src xml
	     <property name="address">
	     <null/>
	     </property>
	     #<null/> 表示向该属性中设置一个空值
	   #+end_src
	2. 属性值包含特殊符号（使用转义符号或者把特殊符号的内容写到CDATA中）
	   #+begin_src xml
	     <property name="address">
	       <value><!<![CDATA[ <<南京>>        
		     ]]> </value>
	     </property>
	   #+end_src
     5. 注入属性(外部bean)
	- 创建两个类service类和dao类
	  在service调用dao里面的方法
	  property的ref标签可以实现外部bean的注入
	- ref指定外部bean的值
     6. 注入属性-内部bean和级联赋值
	#+begin_src xml
	  <beans>
	  <bean id="employ" value="path">
	    <property name="ename" value="lucy"></property>
	    <property name="gender" value="女"></property>
	    <!-- 引入内联对象 -->
	    <property name="dept">
	      <bean id="department" class="/path">
		<property name="dname" value="安保部"></property>
	      </bean>
	    </property>
	    <!-- dept的get方法必须生成，否则不能赋值 -->
	    <property name="dept.dname" value="技术部"></property>
	  </bean>
	  <bean id="dept" class="path">
	    <property name="dname" value="财务部"></property>
	    </bean>
	    </beans>
	#+end_src
     7. xml注入集合类型
**** 注入集合
	#+begin_src xml
	  <!-- 集合类型属性的注入 -->
	  <beans>
	    <bean id="stu" class="path/object">
	      <property name="course">
		<list>
		  <value>java</value>
		  <value>数据库课程</value>
		</list>
	      </property>
	      <!-- 类型属性注入 -->
	      <property name="list">
		<list>
		  <value>rachel</value>
		  <value>beam</value>
		</list>
	      </property>
	      <!-- map类型属性注入 -->
	      <property name="maps">
		<map>
		  <entry key="JAVA" value="java"></entry>
		  <entry key="PHP" value="php"></entry>
		</map>
	      </property>
	      <!-- set标签注入 -->
	      <property name="sets">
		<set>
		  <value>MySQL</value>
		</set>
		</property>
	    </bean>
	  </beans>
	#+end_src
**** 在集合中设置对象类型的值
     #+begin_src xml
       <beans>
       <!--    配置相关创建-->
	   <bean id="user" class="com.asatuoyan.spring5.User">
	     <property name="courseList">
	       <list>
		 <ref bean="course1"></ref>
	       </list>
	       </property>
	   </bean>
	   <!-- 创建多个course对象 -->
	   <bean id="course1" class="path">
	     <property name="cname" value="spring5框架"></property>
	   </bean>
       </beans>
     #+end_src
**** 集合类型提取
     1. 在spring配置文件中引入名称空间util
	#+begin_src xml
	  <beans xmlns="http://www.springframework.org/schema/beans"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
		 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">
	#+end_src
     2. 使用util标签完成list集合注入
**** IOC操作管理(FactoryBean)
     1. Spring有两种类型的bean 一种普通bean,一种工厂bean
     2. 工厂bean定义的类型，可以和返回的类型不一样
     3. 创建工厂bean
	1. 此类实现接口FactoryBean
	2. 实现接口中的方法，在方法中定义返回的bean的类型
	   三个方法
	   - public Course getObject() 决定返回的类型
	   - public Class<?> getObjectType
**** IOC操作的Bean的作用域
     1. bean标签可以是单例对象,也可以多例对象
     2. 在Spring里面，设置创建bean实例是单实例还是多实例
     3. 在Spring里面，默认情况下，bean是单实例对象
	单实例对象，默认地址一样，多实例，默认对象不一致
     4. 在spring配置文件bean标签里面有属性用于设置单实例还是多实例
	- scope属性值
	  1. 默认值 sigleton,表示单实例对象
	  2. prototype, 表示多实例对象
	  3. 设置scope值是singleton时候，加载spring配置文件时候就会吵架单实例
	     对象
	  4. 设置prototype时候，不是在加载spring配置文件时候创建对象,在调用
	     getBean方法时候创建多实例对象
	  5. request 
	  6. session

**** Bean的生命周期
     1. 生命周期
	1. 从对象创建到对象销毁的过程
     2. bean生命周期（加上后置处理器，一共有七步）
	1. 通过构造器创造bean实例（无参数创建）
	2. 为bean的属性设置值和对其他bean引用(调用set方法)
	3. 把bean实例传递bean后置处理器的方法
	4. 调用bean的初始化方法(在bean中initMethod属性可以设置执行此方法)
	5. 把bean实例传递bean后置处理器的方法 
	6. bean可以使用
	7. 当容器关闭时候，调用bean的销毁的方法(需要进行配置销毁的方法)
	   在bean中有destroy-Method属性,需要手动销毁
	   context.close()
     3. 后置处理器效果
	1) 创建类，实现接口BeanPostProcessor, 创建后置处理器
	2) 在初始化之前，执行postProcessBeforeInitialization::bean
	3) 在初始化之后，执行postProcessAfterInitialization::bean
**** Bean自动装配
     1) 根据指定装配规则(属性名称或者属性类型),spring自动将匹配的属性值进行
	注入
     2) bean标签属性autowire,配置自动装配
	autowire属性常用两个值,byName根据属性名称注入，byType根据属性的类型进行
	注入
**** 引入x外部的属性文件
     1. 直接配置数据库的信息
	1. 配置driud连接池,引入外部属性文件方式
	2. 引入德鲁伊连接池依赖jar包
	3. 手动配置
     2. 引入外部属性文件配置数据库连接池
	1. 创建外部属性文件，properties格式文件
	   建议prop.driverClass 不会引发冲突
	2. 把外部properties属性文件引入到spring配置文件中来
*** IOC操作Bean管理(基于注解)
**** 什么是注解
     1. 注解是代码的特殊标记，格式，@注解名称(属性名=属性值,属性名称=属性值)
     2. 使用注解，注解作用在类上面，方法上面，属性上面
     3. 使用注解目的：简化xml配置
**** Spring针对Bean管理中创建对象提供注解
     1. @Component 创建对象
     2. @Service 使用service层
     3. @Controller  使用在web层
     4. @Repository 使用在dao层
     上面四个注解功能是一样的，都可以用来创建bean对象	
**** 基于注解方式实现对象创建
     1. 引入依赖:
	spring-aop-version.jar
     2. 开启组件扫描
	#+begin_src xml
	  <context:component-scan base-package="path1,path2"></context:component-scan>
	  <!-- 开启组件的自动扫描 
	  1. 如果扫描多个包，多个包使用逗号隔开
	  2. 扫描包上层目录
	  -->
	#+end_src
	- 细节配置 如果单独配置了base-package="com.asatuoyan"，则会扫描asatuoyan包下的所有类
	- 配置需要扫描的类
	  use-default-filters="false" 关闭默认过滤器，自己配置规则
	  #+begin_src xml
	    <context:include-filter type="annotation"
				    expression="org.springframework.stereotype.Controller"/>
	  #+end_src
	  - include-filter 设置哪些内容不进行扫描
	  - exclude-filter 设置哪些内容不进行扫描
     3. 注解中的value属性值可以省略不写
**** 基于注解方式实现属性注入
     1. @AutoWired 根据属性类型进行自动装配
	- 把serivce和dao对象创建，在service和dao类创建对象注解
	- 在service注入dao对象，在service类添加dao类型属性，在属性上使用注解
	- 不需要添加set过程
     2. @Qualifier 根据属性的名称进行注入
	- 和AutoWired在一起使用
	  因为一个接口可能多个实现类，根据类型注入
	  @Repository(value="userDaoImpl")
	  @Qualifier(value="userDaoImpl") 根据名称进行注入
     3. @Resource 可以根据类型注入，可以根据名称注入 javax中，不建议使用	           
     4. @Value 注入普通类型属性
**** 完全注解开发
     1. 创建配置类，替代xml配置文件
	@Configuration 把当前类作为配置类,替代配置文件
	@ComponentScan(basePackages="com.asatuoyan") 替代配置文件
	new AnnotationConfigApplicationContext(SpringConfig.class)
** AOP面向切面编程
*** 简介
    1. 面向切面编程(方面)，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得
       业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的
       效率
    2. 通俗描述，不通过修改源代码方式，在主功能增加新功能
    3. 使用登录例子说明AOP
*** AOP底层原理
    1. AOP底层使用动态代理
       1. 有接口,使用JDK动态代理
	  1. 创建接口实现类的代理对象
	  2. 通过代理对象来增强功能
       2. 没有接口情况，使用CGLIB动态代理
	  1. 创建当前类的子类的代理对象
	  2. 通过代理对象来增强功能
    2  使用JDK中的Proxy中来创建代理对象
    2. newProxyInstance方法来实现功能
       - arg1 类加载器
       - arg2 增强方法所在类，这个类实现的接口，支持多个接口
       - arg3 实现这个接口InovationHandler ,创建代理对象，写增强方法
    3. 中间的值做判断	 
*** AOP术语
    1. 连接点
       类里面的哪些方法可以被增强，这些方法称为连接点
    2. 切入点
       实际被真正增强的方法，被称为切入点
    3. 通知(增强)
       1) 实际增强的逻辑部分称为通知
       2) 通知有多种类型
	  * 前置通知 Before
	  * 后置通知 After AfterReturnning AfterThorwing 
	  * 环绕通知 Around 方法执行前后都会执行
	  * 异常通知 
	  * 最终通知
    4. 切面
       1. 把通知应用到切入点的过程
**** AOP操作(准备)
     1. Spring框架一般基于AspectJ实现AOP操作
	1. AspectJ是独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行
	   AOP操作
     2. 基于AspectK实现AOP操作
	1) 基于xml配置文件
	2) 基于注解方式
     3. 在项目里面引入AOP相关的依赖spring-aspects-5.2.9.jar
     4. 切入点的表达式： 知道该对那个类那个方法进行增强
     5. 语法结构:
	execution([权限修饰符][返回类型][类全路径][方法名称][参数列表])
	举例: 对com.asatuoyan.dao.bookDao类里面的add进行增强
	execution(* com.asatuoyan.dao.bookDao.add(..))

*** AOP操作(Aspect注解)
    1) 创建类，在类里面定义方法，对类中的方法进行增强
    2) 在增强类里面，创建方法，让不同的方法代表不同的通知类型
    3) 进行通知的配置
       1. 在spring配置文件中，开启注解扫描
       2. 使用注解创建User和UserProxy对象
       3. 在增强类上面添加注解@Aspect
       4. 在spring配置文件中生成代理对象
    4) 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式来
       配置内容
**** 抽取相同的切入点
     #+begin_src java
       public class UserProxy{
	   @PointCut(value= "execution(* com.asatuoyan.pojo.User.toString())")
	   public void pointdemo(){
	   }
	   @Before(value = "poindemo"){
	   }
       }
     #+end_src
**** 有多个增强类多同一个方法进行增强，设置增强优先级
     @Order(1) 值越小优先级越高
*** AOP操作(Aspect配置文件)
    1. 创建两个类，增强类和被增强类，创建方法
    2. 在spring配置文件中创建两个类对象
    3. 在spring配置文件中配置切入点
       #+begin_src xml
	 <beans>
	 <bean id="book" class="path/to/obj"></bean>
	 <bean id="bookProxy" class="path/to/obj"></bean>
	 <!-- 配置增强 -->
	 <aop:config>
	   <aop:pointcut id="pc" expression="execution(* com.asatuoyan.pojo.User.toString(..))"/>
	   <!-- 配置切面 -->
	   <aop:aspect ref="bookProxy">
	     <!-- 把before方法作用到pc上 -->
	     <aop:before method="before" pointcut-ref="pc">
	   </aop:aspect>
	 </aop:config>
	 </beans>
       #+end_src

** JdbcTemplate
*** 简介
    1. spring框架对JDBC进行封装，使用JdbcTemplate方便对数据库进行操作
    2. 准备，引入相关jar包
       - jdbc
       - tx
       - orm()
    3. 配置JdbcTemplate对象，注入DataSourse
    4. 创建service类，创建dao类，在dao注入jdbcTemplate对象，实现具体操作
       jdbcTemplate.update 数据库的增加修改删除
*** 什么叫事务
    1) 事务是数据库操作最基本单元，逻辑上一组操作，如果成功，那么全都成功。如果
       一个失败，那么全都失败
    2) 类型场景，银行转账
*** spring使用事务
    1. 事务添加到javaEE三层结构里面的Service层(业务逻辑层)
    2. 在spring进行事务管理操作
       1) 有两种方式: 编程式事务管理(即使用try-catch)和声明式事务管理
       2) 基于xml配置文件方式
       3) 基于注解方式
    3. 在Spring进行声明式事务管理，底层使用AOP原理
    4. Spring事务管理API
       1) 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的
	  实现类
    5. 在Spring配置文件中配置事务管理器
       1. 建立事务管理对象
       2. 开启事务注解，并指定你的管理器
       3. 在service类上面，(获取service类里面方法上面)添加事务注解
	  1. @Transactional,这个注解添加到类上边，也可以添加到方法上边
	  2. 如果把这个注解添加类上边，这个类里面所有的方法都添加
	  3. 如果把这个注解方法上，那只是会为方法添加事务
*** 事务操作（声明式事务管理参数配置）
    1. 在service类上面添加注解@Transactional, 在这个注解里面可以配置事务相关数据
    2. propagation 事务的传播行为
       1. 多事务方法直接进行调用，这个过程中事务是如何进行管理的
       2. 事务方法: 对数据库表进行变化的操作
    3. ioslation 事务的隔离级别
       1) 一个未提交事务读取到另一个未提交事务的数据叫脏读
       2) 不可重复读一个未提交事务读取到另一提交事务修改后数据，由于数据的
	  变化，导致未提交的事务读取的数据在变化,这两个事务应该是隔离的.
       3) 幻读，一个未提交事务读到了一个已经提交事务添加的数据
       4) 设置事务的隔离性，就能解决三个读的问题
    4. timeout 超时时间
       事务需要在一定时间内进行提交，如果不提交，就进行事务的回滚
       默认值是-1,设置时间以秒进行计算
    5. readOnly 是否只读
       1) 读: 查询操作 写: 添加修改删除操作
       2) readOnly默认值false
    6. rollbackFor 回滚
       1. 设置出现了哪些异常，会进行事务的回滚
    7. noRollbackFor 不回滚
*** 事务的传播行为
    | 传播属性     | 描述                                                             |
    |--------------+------------------------------------------------------------------|
    | REQUIRED     | 如果有事务在运行，当前的方法就在这个事务内运行，否则，           |
    |              | 就启动一个新的事务，并且在自己事务运行                           |
    |--------------+------------------------------------------------------------------|
    | REUIRED_NEW  | 当前的方法必须启动新事务，并且在它己的事务内运行，如果有事务     |
    |              | 事务在运行，应该将它挂起                                         |
    |--------------+------------------------------------------------------------------|
    | SUPPORTS     | 当有事务在运行，当前的方法就运行在这个事务中，否则，它不可以运行 |
    |              | 在事务中.                                                        |
    |--------------+------------------------------------------------------------------|
    | NOT_SUPPORTS | 当前的方法不应该运行在事务中，如果有运行的事务，将它挂起         |
    |              |                                                                  |
    |--------------+------------------------------------------------------------------|
    | MANDATORY    | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
    |              |                                                                  |
    |--------------+------------------------------------------------------------------|
    | NEVER        | 当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常       |
    |--------------+------------------------------------------------------------------|
    | NESTED       | 如果有事务运行，当前的方法，应该在事务内部，嵌套事务运行，否则就 |
    |              | 启动一个新的事务，并在它自己的事务内运行                         |
    |--------------+------------------------------------------------------------------|
*** 事务操作(XML声明式)
    1. 在spring配置文件中进行配置
    2. 配置事务管理器
    3. 配置通知
    4. 配置切入点
    5. 配置切面

*** Spring5框架新特点
    1. 整个框架基于JDK8,运行时兼容JDK9，许多不建议使用的类和方法在代码库中
       删除
    2. 自代通用的日志封装,也可以自己整合日志工具
       1. Spring5已经移除了Log4jConfigListener,建议使用Log4j2
       2. Spring框架整合Log4j2

** Sping5框架核心容器支持@Nullable
   1) @Nullable注释可以使用在方法属性，参数上面，表示方法返回值可以为空，
      属性值可以为空，方法返回值可以为空
** Sping5核心容器支持函数式风格
   1. 创建GenericApplicationContext对象，调用Context里面的方法,进行注册
      context.refresh();清空内容
   2. 开始注册对象(new 的对象注入到IOC容器中)
      contextregisterBean(User.class() -> new User())
   3. 获取在spring注册的对象
      context.getBean("com.asatuoyan.spring.pojo.User")
      context.getBean("user1");user1为对象的引用
** Spring5支持整合Unit5单元测试框架
   1) 整合Junit4
      - 引入spring相关针对测试的依赖 spring-test
      - 创建测试类，用注解方式完成
	#+begin_src java
	  @RunWith(SpringJUnit4ClassRunner.clas)//指定单元测试的框架版本
	  @ContextConfiguration("classpath:bean.xml") //加载配置文件
	  public class Jtest4{
	      @AutoWired
	      private UserService userService;
	      @Test
	      public void test(){
		  userService.accountMoney();//
	      }
	  }
	#+end_src
   2) 整合Junit5
      - 引入jar包
      - 创建测试类
	#+begin_src java
	  @ExtendWith(SpringExtension.class)
	  @ContextConfiguration("classpath:bean.xml")
	  @SpringJunitConfig(location="classpath:xml") //
	  public clas JTest5{
	      @AutoWired
		  private UserService userService;
	      @Test
		  public void test(){
		  userService.addMoney();
	      }
	  }
	#+end_src

* springWebflux(springMVC)
** TODO Webflux介绍
** 响应式编程
** 
* Thymeleaf
** 定义
** 语法
*** 解析属性
    <a th:href="@{/target}">访问页面</a>
    当它检测到我们使用的是绝对路径
x* SpringMVC
** 配置文件
   #+begin_src xml
     <web-app>
       <!--    配置SpringMVC的前端控制器，对我们浏览器请求来进行统一处理-->
	 <servlet>
	     <servlet-name>SpringMVC</servlet-name>
	     <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
     <!--        配置SpringMVC配置文件的位置和名称-->
	     <init-param>
		 <param-name>contextConfigLocation</param-name>
     <!--            对应类路径-->
		 <param-value>classpath:springMVC.xml</param-value>
	     </init-param>
     <!--        将spring前端控制器dispathcerServlet提前到服务器启动时，不会影响的访问的速度-->
	    <load-on-startup>1</load-on-startup>
	 </servlet>
     <servlet-mapping>
	     <servlet-name>SpringMVC</servlet-name>
     <!--        设置SpringMVC所能控制的请求路径，但是/所匹配的请求很多/login.html .js .css，但是不能匹配.jsp请求路径的请求
		  /* 代表.jsp请求-->
	     <url-pattern>/</url-pattern>
     </servlet-mapping>
     </web-app>
   #+end_src
** 创建请求控制器
   1. 由于不同的请求要有不同的处理方法，springmvc的控制器由pojo担任，因此
      需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IOC容器
      管理，此时SpringMVC才能够识别控制器的存在
   2. 将类标识之后进行扫描，才能将类作为bean进行管理

** spring-mvc配置
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
	 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xmlns:context="http://www.springframework.org/schema/context"
	 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
  <!--    开启组件扫描-->

  <!--    配置视图解析器-->
      <bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
  <!--        视图解析器的优先级，如果有多个视图解析器，优先由谁进行-->
	  <property name="order" value="1"></property>
	  <property name="characterEncoding" value="UTF-8"></property>
	  <property name="templateEngine">
	      <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
		  <property name="templateResolver">
	      <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
  <!--                视图前缀 当视图解析时，视图加上前缀，视图后面加上后缀，来决定跳转到哪个页面 -->
		  <property name="prefix" value="/WEB-INF/templates/"></property>
  <!--                视图后缀-->
		  <property name="suffix" value=".html"></property>
  <!--                模板模型-->
		  <property name="templateMode" value="HTML5"></property>
  <!--                页面编码-->
		  <property name="characterEncoding" value="UTF-8"></property>
	      </bean>
		  </property>
	      </bean>
	  </property>
      </bean>
  </beans>
#+end_src

** @RequestMapping注解
*** 定义
    1. 注解在类上时，为访问路径的初始信息，即
    2. 注解在方法时，为具体信息
    3. 同时使用两者时，th:href="@{/init_info/entity_info}"
    4. value值注解在方法上时必须设置
*** 类的方法
    1. value() String[]  通过当前请求的请求地址来匹配请求
    2. method() RequestMethod[] 通过当前请求的请求方式来匹配请求
    3. params() String[] 通过请求参数来匹配请求

*** 注解method属性
    1. method属性通过请求的方式(get或post)匹配请求映射
    2. method属性是一个RequestMethod类型(枚举类型)的属组，该请求可以匹配多种请求方式的
       请求
    3. 如果请求地址满足映射的value,但是不满足method属性，浏览器报错405
       请求方式不支持
    4. GET传输速度快，数据量量有限,但是不安全，
       POST请求速度慢，数据传输量大
*** 处理指定请求方式的控制器方法
   1. @RequestMapping注解的派生类，用来处理请求
      1. @GetMapping 处理GET请求
      2. @POSTMapping 处理post请求的映射
      3. @PutMapping 处理put请求映射
      4. @deleteMapping 处理delete请求映射
      5. 常用的请求方式get,post,put,delete
       但是目前浏览器只支持get,post,若在form表单提交时，为method设置了其它
       请求方式的字符串，则按照默认的请求方式处理
   2. 若要发送put和delete请求，则需要通过sping的过滤器HiddenHttpMethodFiler
   z
*** 注解的params属性
    1. params属性通过请求的请求参数匹配请求映射,而且请求参数必须同时满足
    2. params属性是一个字符类型的数组，可以通过四种表达式来设置请求参数和
       请求映射的匹配关系
    3. "param": 要求请求映射所匹配的请求必须携带params请求参数
    4. "!param": 要求请求映射所匹配的请求必须不能携带param请求参数
    5. "param=value" 要求请求映射所匹配的请求必须携带param请求参数param=value
    6. "param!=value" 要求请求映射所匹配的请求必须携带param请求参数但是param!=value
       #+begin_src html
	 <html>
	   <body>
	     <a th:href="@{/test(username=admin,password=123456)}">
	       <!-- params={"username"} 必须携带username参数,同时可以设置值 -->
	   </body>
	 </html>
       #+end_src
*** 注解的headers属性
    1. "header" 必须携带header信息
    2. "!header" 必须不携带header信息
    3. "header=value" 必须满足存在header和header=value两个条件
    4. 请求头不匹配，报404错误

** SpringMVC支持ant风格的路径(模糊匹配)
   1. ? ： 表示任意单个字符 /a?a/ 匹配aba aca等
   2. * ： 表示任意的0个或多个字符
   3. ** : 表示任意的一层或者多层目录
   4. 注意： 使用**时，只能使用/**/xxx的方式

** SpingMVC支持路径中的占位符
   1. 原始方式: /deleteUser?id=1
   2. rest方式: /deleteUser/1
   3. SpringMVC路径中的占位符常用于restful风格中，当请求路径中某些数据通过
      的方式传给到服务器中，就可以在相应的@RequestMapping注解的value属性中
      通过占位符(xxx)表示传输的数据，再通过@PathValue注解，将占位符所表示
      的数据赋值给控制器方法的形参
      #+begin_src html
	<a th:href="@{/testPath/1}">'</a>
      #+end_src
      #+begin_src java
	  // 如何获取请求地址中的.利用请求路径中的{}
	// @PathVariable用来修饰形参，将当前参数的值自动赋值给形参
	@RequestMapping("/testPath/{id}/{username}")
	public String testPath(@PathVariable("id")Integer id,@PathVariable("username")String username){
	    return "success";
	}
      #+end_src

** SpringMVC获取请求参数
*** 通过ServletAPI获取
    将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的
    参数表示封装了当前请求的请求提交对象
    1. 根据当前方法的形参，向参数注入对象,形参位置的request表示当前请求
    2. 保证方法中形参的参数名，和请求的参数名保持一致
       #+begin_src java
	 // <a th:href="@{/testParam(username="123456",password="123456")}"
	 @RequestMapping("/testParam")
	 public String testParam(String username,String password){
	     System.out.println("username"+username+",password"+password);
	     return "index";
	 }
       #+end_src
    3. 当请求参数为一个名称对应多个值时，会将请求参数所对应的值以,(逗号)
       形式
    4. 对于同名的请求参数可以通过字符串类型获取，也可以通过字符串类型的数组
       来获取
    5. 若使用字符串类型的形参，最终结果为请求参数的每一个值之间使用逗号进行
       拼接
*** @RequestParam
    1. @RequestParam是将请求参数和控制器方法的形参创建映射关系
    2. @RequestParam注解一共有三个属性
       - value 指定为形参赋值的请求参数的参数名
       - required 设置是否必须传输此请求参数，默认为true
       - boolean
	 1. 设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输
	    该请求参数，且没有设置defaultValue属性，则页面报错400: Required String parammeter "xxx" is not present
	 2. 若设置为false,则当前请求不是必须传输value所指定的请求参数，若没有传输
	    则注解标识的值为null
	 3. defaultValue,不管required属性值为true或false,当value所指定的需求参数没有
	    传输或传输的值为""时
*** @RequestHeader
    1. @RequestHeader 是将请求头信息和控制器方法的形参创建映射关系
    2. @RequestHeader 注解一共有三个属性: value、required、defaultValue,
       用法同@RequestParam

*** @CookieValue
    1. @CookieValue是将cookie数据和控制器方法的形参创建映射关系
    2. @CookieValue注解一共有三个属性: value,required, defaultValue
    3. 将指定的COOKIE和形参进行绑定
       #+begin_src java
      @RequestMapping("/testParam")
      public String testParam(
			      @RequestParam(value="username",required=false)String username){
      }
    #+end_src
    4. 当浏览器创建Cookie以后，每一次浏览器发送请求到服务器，都会携带COOKIE，
       将COOKIE的
*** 通过POJO获取请求参数
    1. 可以在控制方法的形参设置一个实体类类型的形参，此时若浏览器传输的请求参数的
       参数名和实体类中的属性名一致，那么请求参数就会为此赋值
    2. 使用此方法时，POJO中的对象中的属性和请求参数的属性必须一一对应
*** 解决获取请求参数的乱码问题
    1. 解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器
       CharacterEncodingFilter，必须在web.xml
    2. 需要在数据访问前设置，必须在获取请求参数之前
    3. get请求的乱码是由tomcat造成的，需要找到tomcat的配置文件
    4. 监听器,过滤器，Servlet，监听Context创建和销毁
       #+begin_src xml
	 <web-app>
	 <filter>
	   <filter-name>CharacterEncodingFilter</filter-name>
	   <filter-class>org.springframework.web.filter.CharacterEncodingFilter
	   </filter-class>
	   <init-param>
	   <param-name>encoding</param-name>
	   <param-value>UTF-8</param-value>
	 </init-param>
	 <init-param>
	   <param-name>forceResponseEncoding</param-name>
	   <param-value>true</param-value>
	   </init-param>
	 </filter>
	 <filter-mapping>
	   <filter-name>CharacterEncodingFilter</filter-name>
	   <!-- 对所有请求进行操作 -->
	   <filter-class>/*<filter-class>
	   </filter-mapping>
	 </web-app>
       #+end_src      
    6. FilterChain负责放行

** 域对象共享数据
*** 使用ServletAPI向request域共享数据
    #+begin_src java
      @RequestMapping("/testServletAPI")
      public String testServletAPI(HttpServletRequest request){
	  request.setAttribute("testScope","hello,servletAPI");
	  return "success";
      }
    #+end_src
*** 使用ModelAndView向request域共享数据
    ModeAndView有Mode1和View的功能
    - Mode1主要用于向请求域共享数据
    - View主要用于设置视图，实现页面跳转
      #+begin_src java
	@RequestMapping("/testModelAndView")
	    public ModelAndView testModelAndView() {
		ModelAndView modelAndView = new ModelAndView();
	//        处理模型数据，向请求域request共享数据
		modelAndView.addObject("testRequestScope", "hello,ModelAndView");
	//        设置视图名称 即之前返回的视图名称，类似于index.html
		modelAndView.setViewName("success");
		return modelAndView;
	    }
      #+end_src
*** 使用Model,ModelMap向request域对象共享数据
    #+begin_src java
      @RequestMapping("/testModel")
	  public String testModel(Model model){
	      model.addAttribute("testRequestScope","hello,model");
	      return "success";
	  }
    #+end_src   
*** ModelAndView
    1. 在dispatcherServlet中执行转发，都会调用控制器，控制器会返回一个model
       方法

*** 向session域共享对象
    1. 当在session域中使用ModelAndView共享数据时，会在request域中也会生成
       一份数据，所以建议使用原生的setAttribute来传递参数
    #+begin_src java
      @RequestMapping("/testSession")
      public String testSession(HttpSession session){
	  session.setAttribute("testSessionScope","hello,session");
	  return "success";
      }
      // 使用<a th:href="${session.testSessionScope}">；来获取数据
    #+end_src
*** 向application域中共享数据
    1. 类似于session，通过原始方式来获取域对象，servletCOntext代表的就是application域
       
       #+e
      #+begin_src java
	@RequestMapping("testApplication")
	public String testApplication(HttpSession session){
	    ServletContext application=session.getServletContext();
	    application.setAttribute("testApplication","hello,application");
	    return "success";
	}
	// <a th:href="${application.testApplication}"
       #+end_src
** SpringMVC的视图(转发和重定向)
*** 简介
    1. SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示
       给用户
    2. SpringMVC视图的种类很多，默认具有转发和重定向视图
       InternalResourceView和重定向视图RedirectView
    3. 当工程导入jstl依赖，转发视图会自动转换为jstlView
    4. 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Themeleaf的
       视图解析器,由此视图解析器解析之后得到的是ThymeleafView
*** jstl.jar包
    提供了标签，控制页面的内容。
*** View
    1. 当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置
       文件中所配置的视图解析器解析，视图名称拼接视图的前缀和视图后缀所得到的最终
       路径，会通过转发的方式实现跳转
    2. 如果返回的视图前缀为"forward:success",成功后跳转页面为forward,跳转的
       方式为转发, "redirect:success"此时创建的为重定向视图
    3. 如果当前视图前缀forward，那么此时调用的是internalResourceView
    4. SpringMVC中默认的重定向视图是RedirectView
    5. 重定向和转发的区别在此处，转发地址栏显示的Map映射的地址，显示页面是
       跳转之后的页面，重定向地址栏显示解析的thymeleaf视图，

*** COMMENT 视图控制器
    当控制器方法中没有其它请求的处理，只需要设置一个视图名称的时候，就可以
    使用ViewController
    #+begin_src xml
      <beans>
      <mvc:view-controller path="/" view-name="index"></mvc:view-controller>
      </beans>
    #+end_src
    当我们在SpringMVC配置文件中中写了控制器时，当前控制器所写的请求映射将
    全部失效
    - 此时必须开启MVC注解驱动
      #+begin_src xml
	<beans>
	<mvc:annotatio-driven />
	</beans>
      #+end_src
    - 如果使用默认的Servlet处理静态资源时，那么仅仅只有静态资源才会被处理

** RESTFul
*** RESTFul简介
    1. REST: Representational State Transfer 表现层资源状态转移
    2. 类似于面向对象，资源是以名词为核心组织的，首先关注是名词。一个资源
       可以由一个或多个URI来标识。URI即是资源的名称，也是资源在WEB上的地址。
       对于资源感兴趣的客户端应用，可以通过资源的URI与其进行交互
    3. 资源的表述对于资源在某个特定时刻的状态的描述
    4. 状态的转移说的是: 在客户端和服务器端之间转移。通过转移和资源状态的表述
       来间接实现操作资源的目的.
*** RESTFul的实现
    1. 就是HTTP协议中，四个表述操作方式的动词: GET,POST,PUT,DELETE
    2. GET 获取资源
    3. POST用来新建资源，PUT用来更新资源，DELETE用来删除资源
    4. RESTFul风格将资源全部以/方式进行拼接
    |----------+----------+------------------------|
    | 请求路径 | 请求方式 | 功能                   |
    |----------+----------+------------------------|
    | /user    | GET      | 查询所有用户信息       |
    | /user/1  | GET      | 根据用户id查询用户信息 |
    | /user    | POST     | 添加用户信息           |
    | /user/1  | DELETE   | 删除用户信息           |
    | /user    | PUT      | 更新用户信息           |
    |----------+----------+------------------------|
*** 过滤器执行顺序
    1. 按照配置的顺序执行
    2. 字符处理的过滤器放在最前面
*** RESTFul案例
    1. 准备工作
    2. 实现对信息的增加删除修改 代码: idea SpringMVC SpringMVC-jsp    
*** HttpMessageConverter
**** 简介
     1. HttpMessageConverter 报文信息转换器，将请求报文转换文java对象，或java对象
	转换为响应报文，HttpMessageConverter提供了两个注解和两个类:
	@RequestBody, @ResponseBody RequentEntity ReponseEntity
*** @RequestBody
    1. @RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody
    进行标识,当前请求的请求体就会为当前注解所标识的形参赋值
*** @RequestEntity
    1. 此注解可以封装请求报文的类型，需要在控制器方法中设置该类型的形参，当前
       请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过
       getBody()获取请求体信息
*** @ResponseBody
    1. @ResponseBody 标识控制器方法，将java对象直接作为控制器返回，就会转换
       为json格式的字符串
    2. 引入jackson的依赖
    3. 在核心配置文件中开启mvc注解驱动，此时在HandlerAdaptor中会自动装配一个消息
       转换器：MappingJackson2HttpMessageConvenrter,可以将响应到浏览器的java
       对象转换为json格式的字符串
    4. JSON对象是以大括号的形式存储
    5. JSON数组是以中括号的形式存储
    6. 实体类，Map转换换成json对象。list转换成json数组  
       
*** SpingMVC处理ajax
    1. 请求超链接
    2. 通过vue和axios处理点击事件
*** @RestController
    1. 为SpringMVC提供的复合注解，标识在控制器的类上，就相当于为类添加了@Controller
       并且为其中的每个方法添加了@ResponseBody注解

** 拦截器
*** 拦截器的配置
    1. 拦截器拦截控制器方法，三个，一个控制器执行之前，一个在控制器执行之后，
       一个在渲染完毕之后
    2. 两种方式，实现HandlerInterceptor,继承方式已经过时
*** 多个拦截器的执行顺序
    1. 若每个拦截器的preHandle()都返回true
    2. 此时多拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关
    3. preHandle()会按照配置的顺序执行，二postHandle()和afterComplation会
       按照配置的反序执行
** 异常处理器
   1. SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口
      HandlerExceptionResovler
   2. 该接口的实现的类有 DefaultHandlerExceptionResolver(赋值处理默认的
      异常)和SimpleMappingExeceptionResolver(自定义异常)
   3. 当出现了指定的异常，可以设置新的视图名称

** 注解配置SpringMVC
   1. 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainer\
      rinittializer接口的类，如果找到的话用它来配置Servlet容器
   2. Spring提供该接口的实现类,名为SpringServletContainerInitializer,这个
      类又会查找实现WebApplicationInitializer的类并配置的任务交给它们来完成，
      Spring3.2引入了一个遍利的WebApplicationInitiallizer的基础实现,名为
      AbstractAnnotationConfigDispatcherServletInitializer,当我们扩展了
      该类，并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置
      Servlet上下文

** SpringMVC的执行流程
*** 常用组件
    1. DispatcherServlet 前端控制器,不需要工程师开发，由框架提供
       作用: 统一处理请求和响应，是整个流程控制的中心，由它调用其它组件处理用户的请求
    2. HandlerMapping 处理器映射器，框架提供
       作用: 根据请求的url,method,等信息查找Handler,即控制器方法
    3. Handler 处理器，需要工程师开发
       作用: 在DispatcherServlet控制下Handler对具体的用户进行处理
    4. HandlerAdapter: 处理器适配器 由框架提供
       作用: 通过HandlerAdapter对控制器进行执行
    5. ViewResolver； 视图解析器，由框架提供
       作用: 进行视图解析，得到对应的视图
    6. View: 视图
       作用： 将模型数据通过页面展示给用户
*** DispatcherServlet初始化过程
    DispatcherServlet本质上是一个Servlet,所以天然遵循Servlet的生命周期，所以宏观
    上是Servlet生命周期
    该类继承了FrameServlet --> HttpServletBean ---> HttpServlet --> GenericServlet
    首先初始化，查找WebAppllicationContext是否存在，不存在就创建，然后刷新该容器该方法子类DispatcherServlet中进行了重写
    。然后调用初始化策略
*** DispatcherServlet调用组件处理请求
    1. processRequest()
       FrameworkService重写HttpServlet中的service()和doXxx(),这些方法中调用了processRequest(request,response)
    2. 所在类: org.springframework.web.servlet.FrameworkServlet
       proctected final void processRequest(HttpServletRequest request,HttpServletResponse);
    3. Service调用了doXxx()的方法,doXxx()调用了doDispatch()方法
    4. doDispatch()
       执行链：
       1. 我们当前匹配到的控制器的方法
       2. 拦截器集合
       3. 拦截器
* springboot
** 微服务
   1. 是一种架构风格
   2. 一个应用拆分为一组小型服务
   3. 每个服务运行在自己的进程内，就是可以独立部署和升级
   4. 服务之间轻量级HTTP交互
   5. 服务围绕业务拆分
   6. 可以由全自动部署机制独立部署
   7. 去中心化，服务自治，服务可以使用不同的语言，不同的存储技术
** springboot使用
   引入spring-boot插件，直接集成
** 依赖管理
   1. 父项目声明了几乎所以开发中常用的jar的版本号
      1. 配置
      2. springboot自动版本仲裁
      3. 通过properties标签可以引入mysql-version版本
      4. 查看spring-boot-dependencies里面规定当前依赖的版本，用的key
      在当前项目重写配置就行，就近优先
   2. 通过starter引入，可以自己自定义开发场景
   3. 所以启动器都依赖spring-boot
   4. 引入非版本
** springboot自动配置
   1. web开发默认引入tomcat依赖
   2. 配置tomcat
   3. 自动配置springMVC
      - 引入开发的全套组件
      - 自动配好的了springMVC的常用功能
   4. 默认包结构
      - 主程序在包下的所以子包里的组件都会扫描
      - 无需以前的包扫描配置
      - 想要改变扫描路径 
        @SpringBootApplication(scanBasePackages="com.asatuoyan")
      - 或者ComponentScan("") 包扫描
   5. 各种配置都有默认值
      - 默认配置最终都是映射到MultipartProperties
      - 配置文件的值最终后绑定到每个类上，这个类会在容器中创建对象
   6. 按需加载所有自动配置项
      - 非常多的starter
      - 引入哪些场景的自动配置才会开启
      -  springboot所有自动配置都在springboot-autoconfig中
** 容器功能
   1. 配置类中使用@Bean标注在方法上
     #+begin_src java
       @Configuration
       public class MyConfig{
           @Bean
           public User user01(){
               return new User("ahzcw",18);
           }
       }
     #+end_src
   2. 容器中获取组件的对象，默认单实例对象
   3. proxyBeanMethods 代理bean的方法,关闭后，就不会代理对象,每次调用都会产生
      一个新的对象
   4. 配置类本身也是组件
** 导入组件
   1. @Target({User.class,DBHelper.class})
      给容器中自动创建出这两个类型的组件
   2. @Import 写在容器中的组件类中
   3. 不需要创建
** 条件装配
   1. @ConditionalBean 在容器中有某个组件时，才会自动装配，否则不能调用该组件
** 导入配置文件资源 
   1. @importResource导入xml文件中的资源，生效
   2. 指定资源路径后重新解析
** 配置绑定
   1. 只有在容器中的组件，才会拥有springBoot提供的强大功能
   2. enableConfigurationProties(Car.class)
   3. 用java读取到properties文件中的内容，并且把它封装javaBean,以供随时使用
   4. @ConfigurationProperties(prefix="mycar")绑定的前缀
      mycar.price mycar.time
   5. 必须先开启属性配置功能
      EnableConfigurationproperties(Car.class)
      - 开启属性配置

** 自动装配
   1. 自动配好tomcat
      1. 引入tomcat
   2. 引入springmvc
   3. 自动配好Web常见功能
   4. 默认的包结构
   5. 各种配置有默认值
   6. 按需加载自动配置项
** 自动配置原理
   1. 引导加载自动配置类
      - springbootconfiguration
        - configuration 指定配置文件
        - componentscan 指定扫描的内容
        - enableautoconfiguration 开启自动配置
          1. autoConfigurationPacage 将指定的包下的所有组件导入进来
          2. import() 利用import getAutoConfguaration 获取所有导入到容器中的配置类
          3. 利用工程加载 loadSpringFactories 加载得到所有组件
          4. 从META-INF/spring.factories 加载当前系统所有位置的文件
             文件里面写了springboot一启动就要加载所有的配置类
   2. 按照需求开启配置
      1. 虽然默认全部加载配置项
      2. 但是最后会按照条件装配
** 自动配置实例分析
   1. 如果给@Bean 标注的方法传入了对象参数，这个参数的值从容器找
   2. 防止有些用户配置文件上传解析器不符合规范，返回默认符号规范的名称
   3. Springboot默认在底层配置所有组件，但是用户自己配置，以用户的优先
   4. 每个配置文件生效，都会默认绑定配置文件生效和指定的值
** 注意
   1. 取消cmd的快速编辑模式(否则不能直接运行)
   2. springbot自动配置功能(web开发的常见场景)
   3. 默认的包结构，默认扫描主程序下所有子包以及同级目录
   4. 默认配置都是最后映射到具体的类上，这个类会在容器中创建对象
      这些都在springboot-autoconfigure包里面
* springboot实践
**  引入场景依赖
** 查看自动配置项目
   - 自己分析，引入场景对应的自动配置一般都生效了
   - 配置文件中debug=true 开启自动配置报告
** 是否需要修改
   - 参照文档修改配置项
     修改开启时的banner项 指定该图片的项目
   - 自定义加入或者替换组件
   - 自定义器
** 开发技巧
*** lombek（spring-boot默认管理版本）
    引入依赖，安装插件limbek，在bean中只写属性，@Data 帮助生成已有属性的get set方法
    @NoargsConstructor  // 无参构造器 @ToString 
    @AllArgsConstructor // 全参构造器
    @Slf4j  Log.info() 
*** dev-tools
    1. 想要真正热更新，restart 和 reload(付费的jRebei) 当检测到文件的变化
*** spring-initaliz(项目的初始化向导)
    1. 创建项目的结构，引入依赖，创建一个主程序类
** springBoot2核心技术-核心功能
** yaml
*** 简介
    YAML"YAML Ain't Markup language"的递归缩写，在开发语言时，仍是一种标记语言
    非常适合用来以数据为中心的配置文件
*** 基本语法
    - key: valuel key value之间有空格
    - 大小写敏感
    - 使用缩进来表示层级关系
    - 缩进不容许使用tab,只容许空格
    - 缩进的空格数不重要，只要相同层级的元素左对齐即可
    - '@' 表示注释
    - '' 与"" 表示字符串内容转义/不转义
*** 数据类型
    - 字面量：单个的，不可再分的值,date
      k: v
    - 对象: 键值对的集合, map,hash,set, object
      k: {k1:v1,k2:v2}
      k: 
         k1: v1
         k2: v2
         k3: v3
    - 数组: 一组按次序排列的值,array,list,queue
      k: [v1,v2,v3]
      k: 
      - v1
      - v2
      - v3

** 配置自定义的bean提示
   1. 导入spring-boot-configuration
   2. 自动会把属性放到最后
   3. 打包时取消配置处理器
   4. <exclude>打包时候排除
</exclude>
* http协议
** 请求报文
   1. 请求行
      请求的基本信息: 请求方式，访问地址，HTTP协议的版本
   2. 请求（消息）头
      - 作用： 通过具体的参数对本次请求进行详细的说明
      - 格式： 键值对，键和值之间使用冒号隔开
      | 名称           | 功能                                               |
      | Host           | 服务器的主机地址                                   |
      | Accept         | 声明当前请求能够接受的[媒体类型]                   |
      | Referer        | 当前请求来源页面的地址                             |
      | Context-Length | 请求内容的长度                                     |
      | Context-Type   | 请求体的内容类型，这一项的具体值媒体类型中的第一种 |
      | Cookie         | 浏览器访问服务器时携带的Cookie数据                               |
   3. 请求体
      作用： 作为请求的主体，
      1. get方式，没有请求体，但是有一个queryString
      2. post方式，有请求体，formdata
      3. json格式，有请求体，request peyload
      4. 响应头： 服务器发送给浏览器的信息
      5. 响应体： 响应的实际内容
** 会话
   1. HTTP无状态，服务器无法判断两次请求是一个客户端发，还是不同
   2. 通过会话跟踪技术来解决无状态的问题
** 会话
  1. 客户端第一次发请求给服务器，服务器获取session,获取不到，然后响应给客户端.
  2. 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到
     ，服务器就判断这一次请求和上一次请求是同一个客户端，从而能够区分开客户端
  3. 常用的API
     - request.getSession() --> 获取当前的会话，没有创建一个新的会话
     - request.getSession(true) --> 与不带参数相同
     - request.getSession(false) --> 获取当前会话，没有则返回null,不会创建新的
     - session.getId() -> 获取sessionId
     - session.isNew() -? 判断当前session是否最新的
     - session.getMaxInactiveInterval() session的非激活问题时长 默认1800秒
     - session.setMaxInactiveInterval()
     - session.invalidate
     - session.getLastAccessedTime
** 服务器内部转发以及客户端重定向
   1) request.getRequestDispatcher("...").forward(request,response)
      一次请求响应
   2) 客户端重定向 response.sendRedirect("...");
      两次请求响应的过程
* thymeleaf 视图模板技术 
** thymeleaf
   1. thymeleaf jar包 新建ViewBaseServlet 配置两个<context-param>: view-prefix
      veiw-suffix
   2. session 一次会话范围有效
   3. th:href='@{}'
** servlet接口
   - init()
   - service()
     1. GenericServlet 抽象子类 abstract service
     2. HttpServlet抽象子类 实现了service方法，并在内部通过request.getMethod来
        判断请求的方式
     3. 然后根据请求的方式调用内部的do方法，每一个do方法进行了简单实现，主要
        是请求方式不适合，则报405错误,重写的不对，则调用父辈的405
   - destroy()
** 生命周期
   1. 实例化
      - tomcat负责维护servlet实例的生命周期
      - 每个servlet在tomcat容器只有一个实例，它是线程不安全的
      - Servlet的启动时机 :<load-on-startup>
   2. 初始化 
   3. 服务
   4. 销毁
* web开发
** springMVC自动配置概览
** 简单功能分析
** 请求参数处理原理
   1. HandlerMapping中找到能处理请求的（controller.method）
   2. 为当前Handler找一个适配器HandlerAdaptor
      1. 支持方法上标注@RequestMapping
      2. 支持函数式编程的
   3. 传入request,response 目标handler
      1. 执行目标方法
      2. 设置参数解析器（一共26个），确认将要执行的目标的每一个参数值是什么
      3. 当前解析器支持解析那种参数
      4. 支持就调用解析方法
   4. 支持就调用resoloveArgument
      1. 如何确定目标方法每个参数的值
      2. 挨个判断所有参数解析器那个支持解析
      3. 
** 数据响应与内部检测
** 视图解析与模板引擎
** 拦截器
** 跨域
** 异常处理
** 原生Servlet组件
** 嵌入式Web容器
* 定制
** 静态资源规则以及定制化
*** 静态资源目录
    1. 只要静态资源放在类路径下，called /static(or /public or /resources or /META-INF/resources)
    2. 原理： 静态资源拦截所有请求，动态资源也会拦截所有请求。
    3. 优先寻找Controller看能不能处理,不能处理的所有请求交给静态资源处理器
*** 静态资源访问前缀
    1. yaml配置static-path-pattern: /rest/** 访问路径: project/rest/**/
*** webjars
    webjars 自动映射 project/webjars/jquery/3.5.1/jquery.js 
** 欢迎页支持
   - 静态资源路径下 index.html
     - 可以配置静态资源路径
     - 但是不可以配置静态资源的访问前缀，否则导致index.html不能被默认访问
     - controller能处理/index
** 静态资源配置原理
   - SpringBoot启动默认加载 xxxAutoConfiguration (自动配置)
   - springMVC功能的自动配置类WebMvcAutoConfiguration
   - 配置文件的相关属性和xxx进行了绑定
     - WebMvcProperties==spring-mvc
     - ResourcesProperties==spring.resources
   - 一个配置类如果只有一个有参构造器
** 资源处理的默认规则
   - 静态资源路径有默认的四个位置
     #+begin_src java
       private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"};
               private String[] staticLocations;
               private boolean addMappings;
               private boolean customized;
               private final WebProperties.Resources.Chain chain;
               private final WebProperties.Resources.Cache cache;
               }
     #+end_src
   - HandlerMapping 保存了每个Handler能处理哪些请求
** rest风格
   1. 手动开启 spring-boot 表单提交rest 风格
   2. 表单提交会带上_method=PUT参数
   3. 请求过来会被HiddenHttpMethod拦截
      - 请求是否正常，并且是POST方式
      - 获取到_method的值
      - 兼容请求 PUT DELETE PATCH
      - 原生request(post), 包装模式requesWrapper重写了getMethod方法，返回的是
        传入的值
      - 过滤器链放行的时候拥wrapper.以后的方法调用getMethod是调用requestWrapper的
   4. Rest使用客户端工具
      - 

** 如何修改默认method
   #+begin_src java
     @Configuration(proxyBeanMethods = false)
     public class WeConfig {
         @Bean
         public HiddenHttpMethodFilter hiddenHttpMethodFilter(){
             HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
             hiddenHttpMethodFilter.setMethodParam("_m ");
             return hiddenHttpMethodFilter;
         }
     }
   #+end_src
** 请求映射原理
   在确认控制器时 
   - requestmappinghandlermapping 保存了所有的@RequestMapping 和handler的映射
     规则
   - 所有的请求映射在HandlerMapping
   - springBoot自动配置欢迎页的HandlerMapping 访问/能访问到index.html
     - 如果有就找到这个请求对应的handler
     - 如果没有就是下一个HandlerMapping
   - 如果我们需要自定义的映射处理，我们也可以自己给容器中方HandlerMapping，自定义
     HandlerMapping的场景
** 常用参数注解使用
*** 注解
    - @PathVariable(路径变量)
      
    - @RequestHeader(获取请求头)
    - @RequestParam(获取请求参数)
    - @RequestValue(获取cookie值)
*** ServletAPI
*** 复杂参数
*** 自定义对象参数
** 矩阵变量MartrixVaribale
   1. 矩阵变量martrixvaribale
   2. 如果cookie被禁用了，session里面的内容
      session.set(a,b)---> jsessionid ----> cookie ---> 每次发请求都会携带
   3. springBoot默认禁用了矩阵变量的功能,手动开启
      手动开启，原理，对于路径的处理，都是使用UrlPathHelper进行解析的
   4. removeSemicolonContent(移除分号内容) 支持矩阵变量的
   5. 继承类实现可webMvcConfigurar接口，JDK8默认实现了4
      只需要修改一个就行
   6. 矩阵变量要绑定路径变量中
   7. 矩阵变量必须有url路径变量才能被解析
** Map and Model原理
   1. map ,model 里的数据会默认放在request的请求域中
   2. RedirectAttributes(重定向携带数据)
   3. ServletResponse()
   4. map类型的参数，会调用mavContainer.getModel()获取到值
** 目标方法执行完成
   1. 将所有的数据都放在ModelAndViewContainer,包含要去的页面View。还包含Model数据
   2. ，
** 自定义对象参数
   WebDataBinder web数据绑定器，将请求参数的值绑定到指定的JavaBean里面
   WebDataBinder 利用它里面的Converters将请求数据转成指定的数据类型，再次封装
   到JavaBean中
** 自定义Converter原理
   #+begin_src java
     @Override
         public void addFormatters(FormatterRegistry registry) {
             registry.addConverter(new Converter<String, Pet>() {
                 @Override
                 public Pet convert(String source) {
                     if (!StringUtils.hasLength(source)&&!StringUtils.hasText(source)) {
                         Pet pet = new Pet();
                         String[] split = source.split(",");
                         pet.setName(split[0]);
                         pet.setAge(Integer.valueOf(split[1]));
                         return pet;
                     }
                     return null;
                 }
             });
         }
   #+end_src
* 源码解析
** 数据响应与内容协商
*** 响应页面和响应数据
**** jackson.jar + @ResponseBody
     1. 返回值解析器
     2. 15个返回值解析器(寻找返回值处理器能处理返回返回值)
     3. 调用handReturnValue进行处理
     4. RequestResponsebodymethodprocessor可以处理标了@ResponseBody注解的
        - 1. 利用MessageConverters进行处理，将数据写为json
          - 内容协商(浏览器默认会以请求头的方式告诉服务器他能接收什么样的内容类型)
          - 服务器最终根据自身的能力决定服务器能够生产什么样的内容数据
          - springmvc会遍历底层所有的消息转换器(HttpMessageConverter),看是否
            支持将此class类型的对象转为MediaType类型的数据
            例子： Person转换为JSON,或者JSON转为Person
        - 默认的MessageConverter
          - Byte
          - String
          - String
          - Resource
          - ResourceRegion
          - DOMSource(SAXSource,STAXSource,StreamSource,Source)
          - MulitValueMap
          - MappingJackson
          - 支持注解xml处理的
     5. 得到消息转换器将对象转为json
     6. 将json写出去
**** springMVC到底支持
     1. ModelAndView
     2. Model
     3. View
     4. ResponseEntity
     5. ResponseBodyEmitter
     6. StremingReponseBody
     7. HttpEntity
     8. HttpHandlers
     9. DeferredResult
     10. Callable
     11. ListenableFuture
     12. CompletionStage
     13. WebAsyncTask
     14. 有@ModelAttribute
     15. @ReponseBody注解 ---> RequestResponseBodyMethodProcessor
*** 内容协商
    1. 在不同情况下返回不同内容
    2. 引入xml依赖(jackson)
    3. 用postman分别测试返回json和xml, 只需要改变请求头中Accept请求头，告诉服务器
       本客户端可以接收的数据类型
*** 内容协商原理
    1. 首先判断当前响应头中是否已经有确定的媒体类型
    2. 获取客户端(PostMan,浏览器)支持的内容类型（获取客户端Accept请求头字段）
       - contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略
       - HeaderContentNegotiationStrategy 确定客户端可以接收的内容类型
    3. 获取能够产生的媒体类型,遍历所有系统的消息转换器，看谁支持操作对象
    4. 找到支持操作converter,把converter支持的媒体类型
    5. 客户端需要[application/xml],服务端能力[10种,json,xml]
    6. 匹配服务器产生的，浏览器接收的数据类型
    7. 进行内容协商的最佳匹配
    8. 用支持将对象转为最佳匹配媒体类型converter,调用它进行转换
*** 开启浏览器的参数方式的协商功能
    1. 为了方便内容协商，开启基于请求参数的内容协商功能，
       http://project/person?format=json
       spring: contentnegotiation:favor-parameter:true
    2. Parameter策略优先确认是返回json类型数据（获取请求头中format的值）
*** 自定义MessageConverter
    1. 浏览器发请求直接返回xml
    2. 如果是ajax请求返回json
    3. 如果硅谷app发请求，返回自定义协议数据
*** 步骤
    1. 添加自定义的MessageConverter进系统底层
    2. 系统底层就会出所有MessageConverter能操作那些类型
    3. 客户端协商
** 视图解析与模板引擎
   thymeleaf
   1. 所有配置值都在thymeleafProperties
   2. 配置好了SpringTemplateEngine
   3. 配好了ThymeleafViewResolver
** 视图解析原理
   1. 目标方法处理过程中，所有数据都会放在ModelAndViewContainer
   2. 方法的参数是一个自定义类型对象（从请求参数中确定的），把他从新放在Model
      AndViewContainer中
   3. 任何目标方法执行完成后都会返回ModelAndView
   4. 处理派发结果processDispatchResult(页面该如何响应)
      1. render(mv request response): 进行页面渲染逻辑
         1. 根据方法的String返回值得到View对象(定义了页面的渲染逻辑)
         2. 所有的视图解析器尝试是否能根据当前返回值得到View对象
            redirect:/main.html --> thymeleaf new  RedirectView
         3. ContentNegotiation 里面包含所有的视图解析器，内部还是利用视图
            解析器得到视图对象
         4. 视图对象调用自定义的render逻辑进行页面渲染
            1. Redirect如何渲染
            2. 获取目标url地址，然后response.sendRedirect
** 视图解析 
   1. forward 返回值以forward开始: new internalResourceView(ForwardUrl)
   2. 返回值以redirect开始 new RedirectView Reder
   3. 如果返回值是普通字符，new ThymeleafView
   4. 自定义视图解析器
** 拦截器 登录检查于静态资源方行
   1. interceptor 用作登录检查 实现HandlerInterceptor接口
   2. 但是必须放行静态拦截
   3. 指定拦截规则[如果拦截所有，静态资源也会被拦截]
   4. 根据当前请求，找到HandlerExecution,可以处理请求的Handler以及Handler
   所有拦截器
   1. 先拉顺序执行所有拦截器的preHandler方法
      1. 如果当前拦截器执行成功返回为true，则执行下一个拦截器的preHandler
      2. 如果当前拦截器返回为false, 然后倒序执行所有已经执行了的拦截器的
         afterCompletion
   2. 如果任何一个拦截器返回false,直接挑出不执行目标方法
   3. 所有拦截器都返回true,执行目标方法
   4. 倒序执行所有拦截器的postHandler方法
   5. 前面的步骤有任何异常都会直接触发afterCompletion
   6. 页面成功渲染以后，也会倒序触发afterCompletion

** 文件上传原理
   1. 使用文件上传解析器判断并封装文件上传请求（ResultMultiPart来封装）
   2. 参数解析器来解析请求中的文件内容封装成MultipartFile
   3. 将request中文件信息封装为一个 Map<String,MultipartFile>
   4. FileCopyUtils 实现文件流的拷贝
 
* 异常处理
** 错误处理
   - 默认情况下，Spring Boot 提供/error处理所有错误的映射
   - 对于机器客户端，它将组成JSON响应，其中包含错误，HTTP状态和异常消息的详细
     信息，对于浏览器的客户端，响应一个whitetable错误信息，以HTML格式呈现相同
     的数据
   - 要对其进行自定义，添加View解析为error
   - 要完全替换默认行为，可以实现ErrorController，并注册类型的Bean定义，或添加
     ErrorAttribute类型的组件以使用现有机制但替换其内容
   - error/ 下的4xx,5xx页面会被自动解析
** 定制错误处理逻辑
   - 自定义错误页
     - error/404.html error/5xx.html
     - 5xx.html 以5开头的状态码都会响应它
   - @ControllerAdvice+@ExceptionHandler 处理异常 ExceptionhandlerExceptionResolver
   - 实现HandlerExceptionResolver
   - @ResponseStatus+ 自定义异常， 把reponseStatus注解的信息组装成ModelAndView
     底层调用reponse.sendError tomcat发送的的/error
   - spring底层的异常
   - 自定义实现HandlerExceptionResolver 处理异常[O]
** 异常处理（自动配置原理）
   - ErrorMvcAutoConfiguration 自动配置了异常处理规则
     - 容器中的组件 DefaultErrorAttributes --> id ErrorAttributes
   - 容器中的组件 类型： BasicErrorController --> id: basicErrorController
     - 处理默认 /error 路径的请求： 页面响应 new ModelAndView("error",model)
     - 容器中有组件View> id是error(响应默认错误页)
     - 容器中放组件 BeanNameViewResolver(视图解析器)：按照返回的视图名作为的id
       去容器中找View对象，利用视图解析器找到error
   - 如果想要返回页面，就会找到一个白页
     DefaultErrorViewResolver
** 异常处理流程
   1. 执行目标方法，目标方法运行期间有任何异常都会被catch,而且标志当前请求结束，并且用dispathException
   2. 进入视图解析流程(页面跳转)
   3. processHandlerException 处理Handler发生的异常
      1. 遍历所有的handlerExceptionResolvers,看谁能处理当前异常
      2. 系统默认异常解析器，有两个
   4. DefaultErrorAttributes先来处理异常,把异常信息保存到request域中,并且返回
      null;
   5. 默认没有任何处理异常，所以异常会被抛出
      1. 如果没有任何人处理最终底层会发送/error请求,则会被底层的BasicErrorController
      2. 解析错误视图: 遍历所有的ErrorViewResolver, 看谁能解析正常
      3. 默认的default errorResolver 作用是把响应状态码作为错误的地址拼接成
         error/500.html
      4. 模板引擎最终响应这个页面
      5. 注意： 如果错误参数是400, 一般是浏览器的参数没有传递
** 定制错误处理逻辑      
* Web原生组件注入
** 使用Servlet API
   1. 标注注解WebServlet 实现HttpServlet, 主程序添加 
   2. ServletComponenetScan组件都放在哪里
   3. @WebServlet(urlPatherns="/my" 效果： 没有经过spring的拦截器)
   4. 除了可以原生API，但是需要写一个配置类
      1. DispatchServlet如何注册进来
      2. 容器中自动配置了DispatchServlet属性绑定到WebMvcProperties,对应的配置
         文件是spring.mvc
   5. 通过ServletRegistrationBean= DispatcherServlet 把DispatchServlet配置进来
   6. 默认映射的是/路径
   7. 如果多个Servlet能处理同一路径，精确优先原则
      A： /my/
      B: /my/2
   8. 由于MyServlet直接处理，不用经过DisptacherServlet，所以不会被拦截
   9. 嵌入式Servlet容器
      1. 默认支持的webServlet
         - Tomcat.Jetty or Undertow
         - ServletWebServerApplicationContext容器启动寻找ServletWebServerFactory
           并引导创建服务器
      2. 原理
         - springBoot应用启动发现当前是Web应用,web场景包导入tomcat
         - web应用会创建一个Web版的ioc容器
         - ServletWebServerApplicationContext启动时寻找Servlet的Web服务器工厂
         - SpringBoot默认有很多的WebServer工厂
         - 底层会有一个自动配置类 Servlet的Web服务工程自动配置类
         - ServletWebServerFactoryAutoConfiguration导入了
           ServletWebServerFactoryConfiguration,根据动态判断，系统到底导入Web
           服务器的包，默认导入tomcat包
         - web-starter导入tomcat包，容器中有tomcatServletWebServerFactory
         - TomcatServletWebServerFactory创建出tomcat服务器并且启动.
           TomcatWebServer 的构造器拥有初始化方法 initialize....
         - 内嵌服务器，就是手动启动服务器的代码（tomcat核心jar存在）
** 定制Servlet容器
   1. 实现WebServerFactoryCustomizer < ConfigurationServletWebServerFactory>
      1. 把配置文件的值和ServletWebFactory 进行绑定
   2. 修改配置文件server.xxx
   3. 直接自定义ConfigurationServletWebServerFactory
** 定制化的常见方式
   1. @Bean替换
   2. 修改配置文件
   3. xxxxCustomized
   4. 编写自定义的配置类 xxxConfiguration + @Bean 增加容器中的默认组件: 视图解析器
   5. @EnableWebMvc+ @WebConfiguer @Bean 可以全面接管SpringMVC, 所有规则全部自己重新
      配置和扩展功能
   6. 一旦使用@EnableWebMvc注解,把所有系统中WebMvcConfigurer拿过来，所有功能的配置
      都是configurer合起来一起生效，自动配置了一些非常底层的组件，RequestMappingHandlerMapping
      这些组件依赖的都是从容器中获取
   7. WebMvcAutoConfiguraiton里面的配置要能生效必须有一个条件注解
   8. 最终导致了WebMvcAutoConfiguration没有生效
** 使用RegistrationBean
** 嵌入Web容器
** 定制化原理
* 数据访问
** SQL
   1. 导入spring-boot-starter-data-jdbc
   2. 不在JDBC场景时，导入驱动，因为官方不知道我们接下来要操作什么数据库
   3. mysql有默认版本，但是注意数据库版本和驱动版本对应
      1. 想要修改版版，直接依赖引入具体版本(Maven的就近依赖原则)
      2. 重新声明版本(maven的属性的就近优先原则)
** 分析自动配置的类
   1. DataSourceAutoConfiguration: 数据源的自动配置
      - 修改数据源相关的配置: spring-datasource
      - 数据库连接池的配置，是自己容器中没有DataSource才自动配
      - 底层配置好的连接池是： HikariDataSource
   2. DataSourceTransactionManangerAutoConfiguration 事务管理器的自动配置
   3. JdbcTemplateAutoConfiguration JdbcTemplate的自动配置，可以对数据库进行
      crud
      - 可以修改这个配置项ConfigurationProperties(prefix="spring.jdbc")
      - @Bean@Primary JdbcTemplate: 容器中有这个组件
   4. JndiDataSourceAutoConfiguration Jndi的自动配置
   5. XADataSourceAutoConfiguration 分布式事务相关的配置
** 自定义方式整合driud
   1. 自定义
   2. 找starter

** druid引入
   1. 引入druid-starter
   2. 分析自动配置
      - 扩展配置项 spring.datasource.druid
      - DruidSpringAopConfiguration.class 监控SpringBoot的配置项
        spring.datasource.driud.aop-patterns
      - DruidStatViewServletConfiguration.class 监控页的配置
      - DruidWebStatFilterConfiguration.class 
        web监控配置: spring.datasource.druid.web.stat.filter 默认开启
      - DruidFilterConfiguration.class
** 整合MyBatis操作
   1. SpringBoot官方的Starter spring-boot-starter
   2. 引入starter
      1. 全局配置文件 
      2. SqlSessionFactory 自动配置好了
      3. SqlSession 自动配置了SqlSessionTemplate 组合了SqlSession
      4. Mapper 只要我写的操作Mybatis的接口，标注了@Mapper注解就会被自动
         扫描进来
      5. @import(AutoConfiguredMapperScannerRegistrar.class)
      6. 可以不写全局，配置文件，所有全局配置文件的配置都放在Configuration配置
         项中
** 整合Mybatis步骤
   1. 导入mybatis官方starter
   2. 编写mapper接口
   3. 编写sql映射文件并绑定mapper接口
   4. 在application.yaml中指定Mapper配置文件的位置，以及全局配置文件的信息
** Mybatis纯注解版的整合方式
   1. 编写sql映射文件并绑定mapper接口
   2. 在application.yaml中指定Mapper配置文件的位置，以指定全局配置文件的信息
      (配置在mybatis.configuration)
** 注解模式
   1. 引入mybatis-starter
   2. 配置application.yaml中，指定mapper-location位置即可
   3. 编写Mapper接口并标注@Mapper注解
   4. 简单方法直接注解方式
   5. 复杂方法编写mapper.xml进行绑定映射
   6. @MapperScan("com.asatuoyan.admin.mapper") 简化其他的接口信息,不用标注@Mapper
      注解

** 整合MybatisPlus
*** 什么是MybatisPlus
    为了简化mybatis开发而生,建议按照MybatisX插件
*** 自动配置
    1. MybatisPlusAutoConfiguration 配置类，MyBatisPlusProperties配置项绑定
    2. sqlSessionfactory, 自动配置好了,底层是容器中默认的数据源
    3. mapperLocations自动配置好了，有默认值，classpath:/mapper/**/*.xml,任意包
       的类路径下的所有mapper文件夹下，任意路径下的所有xml都是sql的映射文件,
    4. 容器中页自动配置好了SqlSessionTemplate
    5. @Mapper标注的接口也会被自动扫描,建议mapperscan 批量扫描，不用注解mapper
    6. 只需要我们的mapper继承baseMapper就可以拥有crud能力
    7. Mybatis中有一个注解叫tableField(exist=false)
    8. 可以使用TableName("springbootTest") 指明实际使用的表名
** springBoot整合NoSQL场景
*** Redis自动配置
    1. RedisAutoConfiguration 自动配置类 spring.redis.xxx是对redis配置 
       RedisProperties属性类最终操做
    2. 连接工厂是准备好的 LettuceConnectionConfiguration
       JedisConnectionConfiguration
    3. 自动注入了RedisTemplate<Object,Object> xxxTemplate
       StringRedisTemplate
    4. 自动注入了StringRedisTemplate
    5. key: value
    6. 底层只要我们使用StringRedisTemplate, RedisTemplate就可以使用redis
*** redis环境搭建
    1. 阿里云按需付费redis,经典网络
    2. 申请公网连接地址
*** RedisTemplate与Lettuce
    1. filter, Interceptor 几乎拥有相同的功能
    2. filter是servlet定义的原生组件，好处，脱离Spring应用也能使用
    3. Interceptor是spring定义的接口
*** 切换至jedis
** Junit5
*** Junit5的变化
    1. springBoot2.2.0版本开始引入Junit5作为单元测试默认库
    2. 作为最新版本的Junit框架，Junit5与之前版本的Junit框架有很大的不同，由三个
       不同子项目的几个不同模块组成
    3. Junit Platform 在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，
       其他测试引擎也可以接入
    4. JUnit Jupiter 提供了Junit的新的编程模型，是Junit新特性的核心，内部包含
       了一个测试引擎，用于在Junit Platform上运行
    5. Junit Vintage 由于Junit已经发展多年，为了照顾老的项目，Junit Ventage提供
       了兼容Junit4.x 和Junit3.x的测试引擎
    6. 现在版本使用Junit5 @Test  现在方式: @SpringBootTest+@RunWith(SpringTest.class)
*** SpringBoot整合Junit
    1. 编写测试方法：需要使用@Junit5版本的注解
    2. Junit类具有Spring的功能 @AutoWired 比如@Transactional标注的测试方法
       测试完成后会自动回滚
    3. @ParameterizedTest 表示方法的参数化测试
    4. @RepeatedTes 表示方法可重复执行，下方会详细介绍
    5. @DisplayName 为测试类或者测试方法设置展示名称
    6. @BeforeEach 表示每个测试单元之前执行
    7. @AfterEach 表示在每个单元测试之后执行
    8. @AfterAll 表示在所有单元测试之后执行
    9. @Tag 表示单元测试类别，类似于JUnit4中的@Categories
    10. @Disabled 表示测试类或测试方法不执行，类似于Junit4中的@Ignore
    11. @Timeout 表示测试方法运行如果超过了指定时间将会返回错误
    12. @ExtendWith 为测试类或测试方法提供扩展类应用
*** testAfter
*** 断言机制
     断言(assertions)是测试方法中的核心部分，用来对测试需要满足的条件进行验证，这些
     org.junit.jupiter.api.Assertions的静态方法，Junit5内置的断言可以分成如下几个类别
     检查业务逻辑返回的数据是否合理
*** 简单断言
    | 方法            | 说明                                 |
    | assertEquals    | 判断两个对象或者两个原始类型是否相等 |
    | assertNotEquals | 判断两个对象或两个原始对象是否不相等 |
    | assertSame      | 判断两个对象引用是否指向同一个对象   |
    | assertNotSame   | 判断两个对象是否指向不同的对象       |
    | assertTrue      | 判断给定的布尔值是否为true           |
    | assertFalse     | 判断给定的布尔值是否为false          |
    | assertNull      | 判断给定的对象引用是否为null         |
    | assertNotNull   | 判断给定的对象是否不是null[O]        |
*** 组合断言
    assertAll 方法接受多个org.junit.jupiter.api.Executable 函数式接口的实例作为
    要验证的断言，可以通过lambda表达式很容易提供这些断言
*** 异常断言
    assertThrows(ArithmetiicException.class,executable: ()->(int i=10/0))
    断定业务逻辑一定出现异常
*** 前置条件
    Junit5中的前置条件(assumptions[假设])类似于断言，不同之处在于不满足断言会
    使得测试失败，而不满足的前置条件只会使得测试方法终止，前置条件可以看成测试
    方法执行的前提，当该前提不满足时，就没有继续执行的必要
*** 嵌套测试
    1. 外层的Test不能驱动内层的BeforeEachAll之类的方法提前运行
    2. 内层的Test可以驱动外层的Test
*** 参数化测试
    - 参数化测试是JUnit5重要的特性，它使得用不同的参数多次运行测试成为了可能，也为
    我们的单元测试带来了许多便利。
    - 利用@ValueSource等注释，指定入参，我们将可以使用不同的参数进行多次单元测试，
    而不需要每新增一个单元测试，省去了很多冗余代码
    - @ValueSource 为参数化测试指定入参来源，支持八大基础类以及String类型.Class类型
    - @NullSource 表示为参数化测试提供一个null的入参
    - @EnumSource 表示为参数化测试提供一个枚举入参
    - @CsvFileSource 表示读取指定CSV文件内容作为参数化测试人类
    - @MethodSource 表示读取指定方法的返回值作为参数化入参（方法返回需要是一个流）
      
** 如何迁移Junit4到Junit5
* 指标监控
** SpringBoot Actuator
*** 简介
    未来每一个微服务在云上部署以后，我们都需要进行监控，追踪，审计，控制等，SpringBoot
    就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别监控，审计功能
*** 1.x和2.x的不同
    SpringBootActuator 1.x
    1. 支持springMVC
    2. 基于继承方式进行扩展
    3. 层级Metrics配置(指标信息,内存之类的)
    4. 自定义Metrics收集
    5. 默认较少的安全策略
    SpringBootActuator 2.x
    1. 支持SpringMVC,JAX-RS以及WebFlux
    2. 注解驱动扩展
    3. 层级&名称空间Metrics
    4. 底层使用MircoMeter 强大，便捷
    5. 默认丰富的安全策略
*** 如何使用
    1. 引入依赖
    2. 
** ActuatorEndPoint
   1. Health: 监控状况
      返回的是一个总的汇总报告
   2. Metrics 运行时指标
      提供详细的。层级的，空间指标信息，这些信息可以被pull(主动推送)或者
      push（被动获取）方式得到
   3. Loggers 日志记录
** 管理Endpoints
   1. 开启与禁用EndPoints
   2. 
** 编写自定义的健康状态检查信息
   1. 实现AbstractHealthIndicator接口
   2. 指标的注册中心
** spring-boot-admin(可视化的监控)
* 原理解析
** Profile功能
   为了方便环境适配，springboot简化了profile功能
*** application-profile功能
    - 默认配置文件 application.yaml;任何时候都会加载
    - 指定环境配置文件 application-[env].yaml
    - 激活指定环境
      - 配置文件激活
        spring.profiles.group.myprod[0]=ppd
        spring.profiles.group.myprod[1]=prod
      - 命令行激活
        java -jar xxx.jar --spring-profiles.active=prod --person.name=h
        可以修改配置文件的任意值
    - 默认配置与环境配置同时生效
    - 同名配置项, profile配置优先
*** @Profile条件装配功能
    1. 
** 外部化配置
*** 外部配置源
    常用: Java属性文件，YAML,环境变量，命令行参数
*** 配置文件查找位置
    1) classpath 根路径
    2) classpath 根路径下config目录
    3) jar包当前目录
    4) jar包当前目录的config目录
    5) /config子目录的直接子目录
*** 配置文件的加载顺序
    1. 当前jar包内部的application.properties和application.yml
    2. 当前jar包内部的application-[profile].properties和application-[profile].yml
    3. 引用的外部jar包的application.properties和application.yml
    4. 引用的外部jar包的application-[profile].properties和application-[profile].yml
*** 指定环境优先，外部优先后面的可以覆盖前面的同名配置项
** 自定义starter
*** starter启动原理
   - starter-pom 引入autoconfigurer
   - autoConfigure包中配置使用META-INF/spring-factories中EnableAutoConfiguration
     的值，使得项目启动中加载指定的自动配置类
   - 编写自动配置类 xxxAutoConfiguration
     - @Configuration
     - @Conditional
     - @EnableConfigurationProperties
     - @Bean
    引入starter --- xxxAutoConfiguration --- 容器中放入组件 --- 绑定xxxProperties
    --- 配置项
*** 自定义starter
    asatuoyan-hello-spring-boot-starter
 
* SpringBoot原理
** SpringBoot原理
   spring原理[Spring注解] SpringMVC原理,自动配置原理,SpringBoot原理
** springBoot启动过程
   - 创建SpringApplication
     - 保存一些信息 ClassUtils
     - 判定当前应用的类型
     - bootstrappers 初始启动器{List<BootStrapper>}; 去spring.factories文件去找
       org.springframework.boot.Bootstrapper
     - 获取getSpringFactoriesInstance(Class<T> type)
     - 找ApplicationContextInitializer，去spring.factories找ApplcationContextInitializer
       - List<ApplicationContextInitializer<?>> initializer
     - 读取初始化信息之后，寻找监听器 去spring.factories找ApplicationListener
   - 运行SpringApplicaiton
     - StopWatch，保存当前任务的名字，当然任务的时间
     - 创建引导Context(环境) createBootStrapContext
       - 获取到所有之前的bootstrappers 挨个执行initialize 来完成对引导启动器的
         环境设置
     - 让当前应用进入headless模式,java.awi.headless
     - 获取所有RunListener（运行监听器）[为了方便所有Listener进行事件感知]
       - getSpringFactoriesInstance 去spring.factories找SpringApplicationRunListener.class
       - 遍历SpringApplicationRunListener 调用starting方法
       - 相当于通知所有感兴趣系统正在启动过程的人，项目正在starting
     - 保存命令行参数 ApplicationArguments
     - 准备环境信息 prepareEnvironment()
       - 返回或创建基础环境信息对象StandardServletEnviroment
       - 配置环境信息
         - 读取所有的配置源的配置属性值
         - 绑定环境信息
         - 监听器调用 enviromentPrepared; 通知所有的监听器当前环境准备完成
     - 创建IOC容器(createApplicationContext)
       - 根据项目类型(Servlet)创建容器
       - 当前会创建AnnotationConfigServletWebServerApplicationContext
     - 准备applicationContext IOC容器的基本信息
       - 保存环境信息
       - IOC容器的后置处理
       - 应用初始化器： applyInitializers
         - 遍历所有的ApplicationContextInitializer 调用Initialize 来对IOC容器
           进行初始化扩展
         - 遍历所有的Listener调用contextPrepared,EventPublishRunListener;
           通知所有的监听器contextPrepared
       - 执行完成初始化后，所有的监听器又去调用contextLoaded,通知所有的监听器IOC容器已经加载
       - 刷新IOC容器refreshContext()
         - 创建容器中的所有组件（Spring注解）
       - 容器刷新完成后工作 afterRefresh
       - 所有监听器调用 listeners.started(context)
       - 调用着有的Runners，callRunners()
         - 获取容器中的ApplicationRunner
         - 获取容器中的CoomandLineRunner
         - 合并所有Runner并且按照@Order进行排序
         - 遍历所有的runner,调用run方法
       - 如果以上有异常
         - 调用Listener的failed方法
       - 调用所有监听器的running的方法, listeners.running(context)
       - 通知所有的监听器 running如果有问题
** Application Events And Listener
   http://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-feature.html#boot-featyres-application-events
   and listener
   applicationContextInitializer
   applicationListener
   SpringApplicationRunListener
** ApplicationRunner与CommandLineRunner
   1. 
 
