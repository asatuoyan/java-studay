#+TITLE:algorithm 
#+AUTHOR: akinjoker
#+email: asatuoyan@gamil.com
#+INFOJS_OPT: 
#+BABEL: :session *R* :cache yes :results output graphics :exports both :tangle yes 
-----
* 分治算法
** 概述
1. 分治算法把复杂问题分解成简单的算法
2. 可以求解的问题
   - 二分搜索
   - 大整数乘法
   - 棋盘覆盖
   - 合并排序
   - 快速排序
   - 线性时间选择
   - 最接近点对问题
   - 循环赛日常表
   - 汉诺塔
** 基本步骤
1) 分解： 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的
   子问题
2) 解决： 若子问题规模较小，且容易解决则直接解决，否则递归解决各个
   问题
3) 合并： 将各个子问题的解合并为原问题的解。
** 分治算法的设计模式
#+begin_src
  if (P)<=n0
    then return(ADHOC(P))
  for i<- 1 tok
  do yi <- divide and conquer(Pi 递归解决Pi)
  T <- MERGET(y1,y2...yk)
  return(T)
#+end_src
其中|P|表示问题P的规模，n0为一阀值，表示问题P的规模不超过n0时，问题
容易直接解出，不必继续分解。ADHOC(P)是分治算法中的子算法,用于解决
小规模的问题。因此，当P规模不超过n0时，用于直接解决MERGE(y1,y2,y3
,...yk)是该分治法的合并子算法，用于将P的子问题P1,P2,...,Pk的相应的
解y1,y2,...yk合并为P的解
* 动态规划算法
** 背包问题
| 物品 | 重量 | 价格 |
|------+------+------|
| 吉他 |    1 | 1500 |
| 音响 |    4 | 3000 |
| 电脑 |    3 | 2000 |
怎么样装价值最大
** 介绍
1) 将大问题分为小问题解决，从而一步步获取最优的处理算法
2) 动态规划算法和分治算法类似，分解问题，从子问题的解得到原问题的解
3) 动态规划的得到子问题不是相互独立的（即下一解是在上一个解的基础上的）
4) 动态规划可以通过填表的方式逐步推进，得到最优解。
** 解决背包问题的思路和图解
1) 背包问题主要是指一个给定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包
   使其价值最大，其中又分01背包和完全背包（完全背包指每种物品都无限可用）。
2) 这里的问题属于01背包，即每个物品最多放一个，而无限背包可以转换为01背包。
3) 算法的主要思想，利用动态规划来解决，每次遍历到第i个物品，根据w[i]v[i]来确定是否需要将
   该物品放入到背包中，即对于给定的n个物品，设v[i] w[i]分别为第i个物品的价值和重量，C为
   背包的容量，再令V[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值o
* KMP算法
** 暴力匹配的问题
1) 有两个字符串。如果要判断str1是否含有str2。如果存在，就返回
  第一次出现的位置，如果没有，则返回-1。
2) 暴力匹配的思路
   1. 如果当前的字符匹配成功(即str1[i]==str[2])，即i++,j++,继续
      匹配下一个字符
   2. 如果失配（即str1[i]!=str2[j]）,令i=i-(j-1),j=0。相当于
      每次匹配失败时，i回溯，j被置为0。
   3. 用暴力方法解决的话，就会有大量的回溯。每次只移动一位，如果不匹配
      ，移动到下一位接着判断，浪费了大量的时间
** KMP(Knuth Morris Pratt)
*** 算法介绍
1) KMP是一个解决模式串在文本串是否出现过。解决最早出现位置的经典
   算法
2) Kouth-Morris-Pratt字符串查找算法，用于在字符串内查找一个模式串
   P的出现的位置，算法以三个发明者的姓式命名。
3) KMP算法利用之前判断过的信息，通过一个next数组，保存模式串中前后
   最长公共子序列的长度，每次回塑时，通过next数组找到，前面匹配过
   的位置，省去了大量时间
*** 步骤
1. 先得到子串的部分匹配表
2. 使用部分匹配表完成KMP匹配.
3. 使用一个数组，来存储匹配表。
   前缀是指从第一个字母开始到倒数第二个字母之前结束的得由一个字母，
   两个字母，n个字母组成的集合。
   后缀是指从第二个字母开始，到第n个字母结束组成的集合。
* 贪婪算法
** 概述
- 使用贪婪算法，效率高
  目前并没有算法可以快速计算准备的值，使用贪婪算法，可以快速得到非常接近的解，并且效率高，选择策略上，需要覆盖全部地区的最小集合
- 遍历所有的广播电台，找到了一个覆盖了最多未覆盖地区的电台
  - 将这个电台加入一个集合中，把该电台的覆盖地区在下次比较时去掉
  - 重复第1步直到覆盖了全部地区i;
* 普里姆算法(最小生成树)
** 问题
1) 有胜利乡7个村庄(A,B,C,D,E,F,G),现在需要修路把七个村庄联通
2) 各个村庄的距离可以用边线表示(权)，比如A-B距离5公里
3) 问：如何修公路保证各个村庄都能联通，并且总的修建公路总是里程最短
** 算法
1. 修路问题本质就是最小生成树问题（Minimum Cost Tree），简称MST
2. 给定一个带权的无向联通图，如何选取一颗生成树，使树上所有边上权的的总和最小
3. N个顶点，一定有N-1条边
4. 包含全部顶点
5. N-1条边都在图中
6. 举例说明
7. 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法

** 步骤即介绍
1) 普利姆算法求最小生成树，也就是是在包含n个顶点的连通图，找出只有(n-1)条边包含所有n个顶点
   的联通子图，也就是极小联通子图
2) 算法如下
   1. 设置G={V,E}是联通的，T={U,D}是最小生成树，V,U是顶点集合，E,D是边的集合
   2. 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1
   3. 若集合U中顶点ui与集合V,U中的n顶点vj之存在边，则寻找这些边中权值最小边，但不能构成回路，
      将顶点vj加入集合U中，将边(ui,vj)加入集合D中，标记visited[vj]=1
   4. 重复步骤2: 直到U与V相等，即所有顶点都标记为访问过

* Kruskal算法
** 介绍
1) 用来求加权联通图最小生成树算法
2) 从权值从小到大选择n-1条边，并保证n-1条边不构成回路
3) 首先构造一个只含有n个顶点的森林，然后依照权值从小到大选择边加入到森林中，并使得森林不产生回路

* 迪杰斯特拉算法
** 应用场景
1) 有7个村庄(A,B,C,D,E,F,G),6个邮差，从G点出发，需要分别把邮件
分别送到A,B,C,D,E,F六个村庄
1) 各个村庄的距离用边线表示（权），比如A-B距离5公里
2) 问：如何计算出G村庄到其它各个村庄的最短距离
3) 如果从其它点出发到各个点的最短距离是多少
** 介绍
1. 用于计算一个节点到其它节点的最短路径。主要特点是以起始点为中心，向
   外层层层扩展，直到扩展到终点为止
2. 算法过程
   1. 设置出发点为v,顶点集合V{v1,v2,vi...},v到V中各顶点的距离构成
      距离集合Dis.Dis{d1,d2,di...},Dis集合记录看v到图中各顶点的距离
      (到自身可以看作0,v到vi距离对应为di)
   2. 从Dis中选择最小的di并移出Dis集合,同时移出v集合z中对应的顶点vi，此时
      的v到vi即为最短路径
   3. 重复执行两步骤，直到最短路径顶为目标顶点即可结束
** 思
路
1. class VisitedVertex{} 已经访问顶点集合
2. public int[] already arr;记录各个顶点是否访问过,1表示访问
   过，0未未访问，会动态更新
3. public int[] pre_visited;//每个下标对应的值为前一个顶点下标
   动态更新
4. public int[] dis;//记录出发顶点到其他所有顶点的距离，比如G为出发
   顶点，就会记录G到其它顶点的距离，动态更新，求的最短距离就会存放到
   dis

* floyd算法
** 问题
1) 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径为Lkj,顶点vi到vj的路径为Lij,
   则vi到vj的最短路径为 min((Lik+Lk),Lij) vk的取值为图中所有顶点，则可获得vi到vj的最短
   路径
2) 至于vi到vk的最短u路径Lik或者vk到vj的最短路径Lkj，同样方法获得
3) floyd算法维护了一个中间节点的数组，通过每个节点作为中间节点的所有情况
* 骑士周游算法
** 马踏棋盘
1. broad[7][7]的某个方格中，马按走棋规则进行移动，要求每个方格只进入一次，走编棋盘上全部64
   个方格
** 思路
- 创建棋盘cheeseBoard，是一个二维数组
- 将当前位置设置为已经访问，然后根据当前位置，计算马儿还可以走哪些位置，并放入到一个集合中
  (ArrayList)最多有8个位置
- 遍历ArrayList中的所有位置，看看哪个位置可以走通
- 判断马儿是否完成了任何，使用step和应该走的步数比较，如果没有达到数量，由于表示没有完成任务，
  将整个棋盘置0
- 马儿不同的走法，会得到不同的结果，效率也会影响


