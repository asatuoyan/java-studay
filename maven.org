* 自动化构建工具
** 软件层次
   - 视图层/表述层/表现层
   - 控制层 Servlet/Action/Handler
   - 业务逻辑层 Spring IOC AOP
** 目前的技术在开发中存在的问题
   1. 一个项目就是一个工程
      如果项目非常庞大，就不适合继续使用package来划分模块,最好每个模块对应
      一个工程，利于分工协作
   2. 项目中需要的jar包必须手动"复制"，"粘贴"到WEB-INF/lib目录下
      带来的问题，同样的jar包文件重复出现在不同的项目工程中,工程比较臃肿
      借助maven，我们可以直接引用工程
   3. jar包需要别人替我们准备好，或到官网下载
   4. 一个jar依赖的其它jar包需要自己手动加入到项目中
   5. maven会自动导入被依赖的jar
* Maven
** 定义
    1. Maven服务java平台的自动化构建工具
       Make-Maven-Gradle
    2. 概念: "java源文件","框架配置文件","JSP","HTML","图片"等资源为"原材料",表示
       ：生成一个可以运行的项目的过程
    3. 编译: Java源文件(User java)->编译->Class字节码文件(User.class)交给虚拟机
       去执行
    4. 部署: 一个BS项目最终运行的并不是动态Web工程本身, 而是这个动态Web工程
       编译的结果
** Maven运行时环境
   1. 将jar包引用到目录中，开发过程中，所有路径或文件中配置的路径等都是以编译
      结果的目录结构为标准的
** 构建过程的几个主要环节
   1. 清理 将以前得到的旧的class字节码文件删除，为下一次编译做准备
   2. 编译 将java源程序编译成class字节码文件
   3. 测试 自动测试,自动调用junit程序
   4. 报告 测试程序执行的结果
   5. 打包 动态web工程打war包，java工程jar包
   6. 安装 Maven特定概念---将打包得到的文件复制到仓库中的指定位置
   7. 部署 将动态工程Web生成的war包复制到Servlet容器的指定目录下，使其可以
      运行
   - 自动化构建
** 安装Maven核心程序
   1. 检查JAVA_HOME环境变量
   2. 解压Maven核心程序的压缩包，放在一个非中文无空格路径下
   3. 运行mvn -v 查询maven版本验证是否
   4. 配置Maven相关的环境变量
      1. MAVEN_HOME或M2_HOME
      2. path
** 依赖的原则说明
   1. 就近优先（如果多个依赖导入了同一包)
   2. 解决模块之间的jar包冲突问题
   3. 路径优先级相同时，先声明是<dependency标签的声明顺序
** 统一管理依赖的版本
   1. 建议配置方式，使用properties标签统一声明版本号
   2. 在properties标签内使用自定义标签声明版本号
   3. 通过引用properties内的标签，来统一版本号${tag}
** Maven继承
   1. 由于非compile范围的依赖是不能在依赖链中传递，所以需要的工程只能
      单独配置
   2. 统一管理各个模块中对Junit依赖的版本
   3. 将junit依赖统一提取到父工程，在子工程中声明Junit依赖时不指定版本，
      以及父工程中统一设定的为准，同时也便于修改
   4. 操作步骤
      1. 创建一个maven父工程，注意： 打包方式为pom
      2. 在子工程声明对父工程的引用
      3. 将子工程的坐标中与父工程坐标中重复的内容删除
      4. 在父工程中统一声明junit的依赖
      5. 在子工程删除junit依赖的版本号
      6. 配置继承后，执行安装命令时，要先安装父工程
** 聚合
   1. 作用： 一键按照各个模块工程
   2. <modules>内部指定子工程的相对路径
   3. 配置方式： 在一个"总的聚合工程"中配置各个参与聚合的模块
   4. <build> 配置当前工程创建过程中的特殊设置
   5. <plugins> 配置过程中使用的插件
   6. cargo是一家专门从"启动Servlet容器"的组织
   7. 针对插件进行的配置

* Maven的核心概念
** 简介
   1. 约定的目录结构
      1. 创建约定的目录结构
	 - 根目录:工程名
	 - src目录: 源码
	 - pom.xml
	 - main目录 存放主目录
	 - test目录 存放测试程序
	 - java目录 存放java源文件
	 - resources目录 存放框架或其它工具的配置文件
      2. 为什么遵守约定的目录结构
	 - Maven要负责我们这个项目的自动化环境,以编译过程为例，Maven要想自动
	   进行编译，那么它必须知道java源文件保存在哪里
	 - 如果自己定义的东西想要让 框架或工具知道，有两种方法
	   1. 以配置的方式
	   2. 遵守框架的约定
	      log4j.properties log4j.xml
   2. POM
   3. 坐标
   4. 依赖
   5. 仓库
   6. 生命周期
** 静态导入
   - 静态导入
** 常用的maven命
   1. 注意: 执行与构建过程相关的Maven命令,必须进入pom.xml所在的目录,与构建
      过程相关: 编译，测试，打包....
   2. 常用的命令
      - mvn clean 清理 
	清理构建得到的产品
      - mvn compile 编译
      - mvn test compile 编译测试程序
      - mvn tesst 执行测试
      - mvn package 打包
** 关于联网问题
   1. Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的
      插件来完成,而插件本身并不包含在核心程序中
   2. 当我们执行的maven命令需要用到某些插件时,Maven核心程序会首先到本地仓库
      中查找
   3. 本地仓库的默的位置: /home/akinjoker/.m2/repository
   4. maven程序如果在本地仓库中找不到需要的插件,那么它会自动连接外网到中央仓库
      去下载
   5. 如果此时无法连接外网，则构建失败
   6. 修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找
      插件
      - 找到Maven的解压目录/config/setting.xml
      - 在setting文件中找到标签,将<localRepository >/path/local/repo </local\
   Repository>中 取出
      - 将标签体内容修改为已经准备好maven仓库的目录
 
** POM
   1. Project Object Model 项目对象模型
   2. pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件
      中进行配置
   3. 重要程度相当于Web.xml对于动态Web
   4. 坐标
      1. 数学中的坐标
	 - 在平面上，使用X,Y两个向量可以定位平面中的任何一个点
	 - 在空间中，使用X,Y,Z三个向量可以唯一定位空间中的任何一个点
      2. Maven的坐标
	 - 使用下面三个向量在仓库中唯一定位一个Maven工程
	   1. groupid 公司或组织域名倒序+项目名
	   2. artifactid 模块名
	   3. version 版本
	 - 坐标和仓库中路径的对应关系
** 仓库
*** 仓库的分类
    1. 本地仓库
       当电脑上部署的仓库目录，为当前电脑上所有的Maven工程服务
    2. 远程仓库
       1. 局域网(私服): 搭建在局域网中。为局域网范围内所有Maven工程服务
       2. 中央仓库： 架设在internet 上，为全世界所有的Maven服务
       3. 中央仓库的镜像
	  为了分担中央仓库的流量.提升用户访问的速度
    3. 仓库中保存的内容 Maven工程
       - Maven 自身所需要的插件
       - 第三方框架或工具的架构
       - 我们自己开发的Maven工程
*** 依赖的基本操作
    1. maven解析依赖信息时，到本地仓库中查找被依赖的jar包.
       对于我们自己开发的maven工程，使用Install命令按照后就可以进入仓库
    2. install将编译结果打包复制到本地仓库 
*** 依赖的范围
    1. 依赖的范围有几个可选值，用得到的是compile,test,provided
    2. compile test provided(不参与部署，servlet服务器提供)
       - 对主程序有效 compile  provided
       - 对测试程序是否有效 compile test provided
       - 是否参与打包 compile
       - test列子: junit
** 生命周期
   1. Maven 核心程序里定义了抽象的生命周期
   2. 各个构建环节执行的顺序
      - 清理
      - 编译
      - 报告
      - 打包
      - 安装
      - 部署
   3. 生命周期各个具体每个阶段的任务
      1) Clean Lifecycle在进行真正的构建之前进行一些清理工作
      2) Default Lifecycle构建核心部分，编译，测试，打包，安装，部署
      3) SiteLifeCycle 生成项目报告，站点，发布站点
   4. Site生命周期
      1) pre-site 执行一些需要生成站点文档之前完成的工作
      2) site 生成项目的站点文档
      3) post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
      4) site-deploy 将生成的站点文档部署到特定的服务器
   5. Maven核心程序为了更好的实现自动化构建，按照这样的特点执行生命周期的各个
      阶段，不论现在要执行生命周期哪一个阶段,都是从这个生命周期最初的位置开始
      执行
   6. 插件和目录
      1. 生命周期的各个阶段仅仅定义了它要执行的任务是什么
      2. 各个阶段和插件的目标是对应的
      3. 相似的目标由特定的插件来完成
 | 生命周期阶段 | 插件目标     | 插件                  |
 | compile      | compile      | maven-compiler-plugin |
 | test-compile | test-compile | maven-compiler-plugin |
** default默认生命周期	 
** 依赖的传递性
   1. 可以传递的依赖不必在每个工程模块中重复声明
   2. 非compile范围的依赖不能传递
* 使用Maven
** Maven
   1. Maven插件，Eclipse内置
   2. Maven插件的设置
      1) installations: 指定Maven核心程序位置，不建议使用插件自代的maven程序,
	 而使用自己解压那个
      2) user settings: 指定conf/settings.xml的位置，进而获取本地仓库的位置
   3. 设置通过Maven创建的工程JDK版 
   4. 基本操作
** 根据坐标创建Maven工程
+ groupId 公司或组织的Id
  公司或者组织名的倒序，通常会加上项目名称
+ artifactId: 一个项目或者是项目中的一个模块，将来作为Maven工程的工程名
+ version 版本号
  - 
** 需要设置依赖排除的场合
   1. 需要设置排除的依赖
   2. <dependency> 内部exclusions指定排除的包 

